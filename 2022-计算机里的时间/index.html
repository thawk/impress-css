<!doctype html>
<html lang="zh-cmn-Hans">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <title>计算机里的时间</title>
    <link href="css/tachyons.min.css" rel="stylesheet" />
    <link href="impress.js/css/impress-common.css" rel="stylesheet" />
    <link href="css/fonts.css" rel="stylesheet" />
    <link href="css/classic-slides.css" rel="stylesheet" />
    <link href="css/themes/github.css" rel="stylesheet" />
    <link href="impress.js/extras/highlight/styles/github.css" rel="stylesheet" />
  </head>
  <body class="impress-not-supported">
    <div class="fallback-message">
      <p>您正在使用的浏览器<b>不支持</b>impress.js需要的功能，因此只能看到简化版本。</p>
      <p>请使用最新版本的<b>Chrome</b>、<b>Safari</b>或<b>Firefox</b>浏览器以取得最佳效果。</p>
    </div>

    <div id="impress" class="nodebug" data-width="1920" data-height="1080" data-autoplay="0" data-max-scale="4">

      <!-- title页放到其他页上面，避免在overview页面上被遮挡 -->
      <div id="title" class="step slide title" data-rel-position="relative" data-scale="3" data-x="0" data-y="-200" data-z=1100>
        <h1>计算机里的时间</h1>
        <p>交易结算研发部 谭浩通</p>
        <p><small>2022-01-11</small></p>
      </div>

      <div id="目录" class="step slide" data-rel-x="0" data-rel-y="2h" data-rotate=0 data-z=1000>
        <h3 class="w-100 tc pb4">目录</h3>
        <ul class="flex list">
          <li class="w-33 tc pa3">
            <img height="400" src="images/记忆的永恒.jpg" alt=""/><br>
            时间的由来</li>
          <li class="w-34 tc pa3">
            <img height="400" src="images/World_Time_Zones_Map.png" alt=""/><br>
            时区的由来</li>
          <li class="w-33 tc pa3">
            <img height="400" src="images/computer-clock.jpg" alt=""/><br>
            时间的应用</li>
        </ul>
      </div>

      <div id="时间的由来" class="step slide title box flex flex-column justify-center" data-rotate-z="-90" data-x="-6250" data-y="0" data-goto-key-list="ArrowDown" data-goto-next-list="时区的由来">
          <h2>时间的由来</h2>
          <img height="400" class="center" src="images/记忆的永恒.jpg" alt=""/></li>
      </div>

      <!-- 以右下角为旋转轴。对向量(w/2, h/2)计算旋转后的位置，以w/2相加前者，以h/2相减后者 -->
      <div id="自然时间" class="step slide" data-rel-rotate-z="19" data-rel-x="2043.50" data-rel-y="341.97">
        <h3>自然时间</h3>
        <p>根据自然（天文）现象定义时间</p>
      </div>

      <div id="天" class="step slide cf" data-rel-rotate-z="0" data-rel-x="-0.25w" data-rel-y="0.25h" data-scale=0.5>
        <h3 class="tc">天</h3>
        <img class="fr" src="images/日晷.png">
        <ul>
          <li>1 天 = 两次日上中天（视太阳日）</li>
          <li>1 秒 = 1 / 24 * 60 * 60 = 1 / 86400 天</li>
          <li>每天是等长的吗？—— 平太阳日</li>
        </ul>
        <div class="notes">视太阳日/平太阳日</div>
      </div>

      <div id="年" class="step slide cf" data-rel-x="0.5w" data-rel-y="0" data-scale=0.5>
        <h3 class="tc">年</h3>
        <img class="fr" src="images/圭表.png">
        <ul>
          <li>1 年 = 两次冬至（岁实，回归年）</li>
          <li>1回归年 = 365.2421990741日<br>
            <span class="o-0">1回归年</span> = 365天5小时48分46秒</li>
          <li>回归年比恒星年短20分24秒</li>
        </ul>
        <div class="notes">
          岁实是中国用的回归年，是从冬至再回到冬至所经历的时间。
        </div>
      </div>

      <div id="skip1" class="step slide hide-step" data-rel-to="自然时间" data-rel-x="0" data-rel-y="0">
      </div>

      <div id="世界时" class="step slide" data-rel-inherit="自然时间" >
        <h3>世界时</h3>
        <ul>
          <li>对一年内所有天的长度取平均，得到相对平均的天和秒</li>
          <li>在 1927 年，人们以基于“天文现象”+“钟表计时”，确立了第一套时间标准：<strong>世界时</strong>（Universal Time，简称 UT）</li>
          <li>格林尼治标准时间（Greenwich Mean Time，简称 <strong>GMT</strong>），就是指的世界时</li>
        </ul>
        <div class="notes">
          <ul>
            <li>人们发现，地球的公转轨道并不是一个正圆，而是一个“椭圆”，也就是说公转速度是“不均匀”的 ，每天太阳照射同一位置的时间也有误差。
            <li>也就是说，依据地球公转计算出的“天”不是等长的，那根据天推算出的秒，自然也不是“等长”的。
          </ul>
        </div>
      </div>

      <div id="原子钟" class="step slide">
        <h3>原子钟</h3>
        <ul>
          <li>地球自转变慢，以此定义的时间不准</li>
          <li>在 1967 年，国际度量衡大会决定以<strong>铯原子</strong>跃迁 9,192,631,770 个周期，所持续的时间长度定义为 1 秒</li>
          <li>基于原子钟确立的时间标准，叫做“<strong>国际原子时</strong>”（International Atomic Time，简称 TAI）</li>
        </ul>
        <div class="notes">
          <ul>
            <li>随着科技的发展，人类对太阳的观测越来越精准， 人们发现，地球每天的自转速度也“不是匀速”的，地球的自转受到潮汐、地壳运动、冰川融化、地震等自然现象的影响，越来越慢！
            <li>这会导致之前规定的，每年平均下来一天的时间，现在来看，也是不一样长的。
          </ul>
        </div>
      </div>

      <div id="协调世界时" class="step slide flex flex-column">
        <h3>协调世界时（UTC）</h3>
        <div class="flex justify-center items-center h-100">
          <img class="svg" src="images/utc.drawio.svg" width="80%" height="auto" alt=""/>
        </div>
        <div class="notes">
          <ul>
            <li>原子钟稳定</li>
            <li>世界时随着地球自转变慢</li>
            <li>如果两者相差过大时，就“人为”地调整一下时钟，让两者相差不超过 0.9 秒 → “闰秒” </li>
            <li>基于原子时 + 世界时“协调”得出 → 协调世界时（Coordinated Universal Time，简称 UTC）</li>
            <li>The first leap second occurred on 30 June 1972. Since then, leap seconds have occurred on average about once every 19 months, always on 30 June or 31 December. As of July 2021, there have been 27 leap seconds in total, all positive, putting UTC 37 seconds behind TAI.</li>
          </ul>
        </div>
      </div>
      
      <div class="step slide skip hide-step"></div>

      <div id="时区的由来" class="step slide title box flex flex-column justify-center" data-goto-key-list="ArrowUp ArrowDown" data-goto-next-list="时间的由来 时间的应用">
          <h2>时区的由来</h2>
          <img height="400" class="center" src="images/World_Time_Zones_Map.png" alt=""/>
          <div class="notes markdown">
- 为什么要有时区？
- 为什么没有``Asia/Beijing``时区？
- 应该用什么时区？
          </div>
      </div>
      
      <div id="为什么要有时区？" class="step slide">
        <h3>为什么要有时区？</h3>
        <p>交通发达 → 旅行速度加快 → 跨时区</p>

        <blockquote class="substep">
          <h4>罗德岛火车相撞</h4>
          1853年8月12日，美国东部罗德岛州，两辆火车迎头相撞，14人因此死亡。事故的原因在今天看来难以置信——两车工程师的手表差了2分钟。
        </blockquote>
      </div>
      
      <div id="时区的设立" class="step slide markdown">
### 时区的设立
- 1863年，首次使用时区的概念。时区通过设立一个区域的标准时间部分地解决了时间差问题
- 1870年代加拿大铁路工程师弗莱明首次提出全世界按统一标准划分时区
- 1883年11月18日，美国铁路部门正式实施五个时区
- 1884年华盛顿子午线国际会议正式通过采纳这种时区划分，称为**世界标准时制度**
      </div>
      
      <div id="时区的定义" class="step slide">
        <h3>时区</h3>
        <div class="flex items-center">
          <div class="w-50 f2 markdown">
时区是地球上的区域使用同一个时间定义。

- 从格林威治本初子午线起，经度每15度划分一个时区，时间相差一小时
- 目前时区最小单位是15分钟：尼泊尔``UTC+5:45``
- 时区不只±12小时：基里巴斯（莱恩群岛） UTC+14
- UTC可以在时间后面直接加上一个“Z”（不加空格）
  - “14:45:15 UTC”可写为“14:45:15Z”或“144515Z”
- UTC偏移量
  - ``±[hh]:[mm]``、``±[hh][mm]``、或``±[hh]``
  - ``22:30:05+08:00``、``223005+0800``或``223005+08``
          </div>
          <div class="w-50"><img src="images/World_Time_Zones_Map.png" alt=""></div>
        </div>
        <div class="notes">
          <ul>
          <li>出于行政管理或其他原因，时区并不严格按照南北直线来划分</li>
          <li>国际日期变更线</li>
          </ul></div>
      </div>

      <div id="世界时区图" class="step slide" data-rel-rotate-z="0" data-rel-x="0.25w" data-rel-y="0" data-scale="0.5">
      </div>

      <div id="时区-中国" class="step slide slide skip" data-rel-to="世界时区图" data-rel-x="0.09w" data-rel-y="-0.05h" data-scale="0.15" data-goto="世界时区图">
      </div>
      
      <div id="时区-群岛" class="step slide slide skip" data-rel-to="世界时区图" data-rel-x="-0.2w" data-rel-y="0.02h" data-scale="0.1" data-goto="世界时区图">
      </div>
      
      <div id="中国时区" class="step slide" data-rel-inherit="时区的定义" >
        <h3>中国时区</h3>

        <div class="flex items-center justify-center">
          <div class="markdown f2 w-40">
- 1912年以前中国没有划分时区
- 1912年中华民国成立，分为五个时区：
  1. ``Asia/Kashgar``，**昆仑时区**
     - 东经82度半，GMT+5:30
  2. ``Asia/Urumqi``，**新藏时区**
     - 东经90度，GMT+6
  3. ``Asia/Chongqing``，**陇蜀时区**
     - 东经105度，GMT+7
  4. ``Asia/Shanghai``，**中原标准时区**
     - 东经120度，GMT+8
  5. ``Asia/Harbin``，**长白时区**
     - 东127度半，GMT+8:30
          </div>
          <img class="w-50" src="images/ROC-Timezones.svg" alt=""/>
        </div>
      </div>

      <div id="新中国的时区" class="step slide markdown">
### 新中国的时区
- 1949年中华人民共和国成立，全国统一使用(UTC+8)，并命名为**北京时间**（或称作中国标准时间）
- 新疆、西藏在1970年底之前使用东经90度标准时，1971年开始使用东经120度标准时
- 北京时间并不是北京市的地方平太阳时间（东经116°23'），而是东经120°的地方平太阳时间，二者相差约14分钟28秒
- IANA对政治变更保持中立性，时区通常不与国家绑定，也并不要求每个国家或国家首都必须具有时区名称
  - 北京时间使用**Asia/Shanghai**
      </div>
      
      <div class="step slide skip hide-step"></div>
      
      <div id="时间的应用" class="step slide title box" data-goto-key-list="ArrowUp ArrowDown" data-goto-next-list="时区的由来 取时间的方法">
          <h2>时间的应用</h2>
          <table class="borderless w-90">
            <tr>
              <td class="w-33"><strong>计算机怎样计时</strong></td>
              <td class="w-33">取时间的方法</td>
              <td class="w-34">等待时间的方法</td>
            </tr>
            <tr>
              <td class="w-33 markdown">
- 时钟原理
- 时钟类型
              </td>
              <td class="w-33"></td>
              <td class="w-34"></td>
            </tr>
          </table>
      </div>
      
      <div id="计算机怎样计时" class="step slide">
        <h3>计算机怎样计时</h3>
        <div class="flex items-center">
          <div class="w-50 markdown f1">
- 关机时，RTC模块持续计时
- 启动时，操作系统从RTC读取时间
- 运行时，操作系统通过晶振的中断计时
- 关闭时，操作系统把时间同步到RTC中

**RTC**: Real Time Clock
          </div>
          <img class="w-50" src="images/rtc.png" alt="">
        </div>
      </div>
      
      <div id="时钟类型" class="step slide">
        <h3 class="w-100 tc">时钟类型</h3>
        <div class="flex">
          <div class="w-50 markdown">
#### 系统时钟 Wall Clock
- 可以表示具体年月日时分秒
- 受校时影响
- 时间**可能倒退**
- 适合用于**展示**
          </div>
          <div class="w-50 markdown">
#### 单调时钟 Monotonic Clock
- 从某个时点开始经过的时间
- **不**受校时影响
- 时间单调增长
- 适合用于**计算时间差**
          </div>
        </div>
      </div>

      <div id="时钟应用场景" class="step slide">
        <h3>几个应用场景</h3>
        <ul>
          <li class="substep">
            <strong class="dib w-50">审计日志中的操作时间：</strong>
            <span class="substep">系统时钟</span>
          </li>
          <li class="substep">
            <strong class="dib w-50">通信超时时间：</strong>
            <span class="substep">单调时钟</span>
          </li>
          <li class="substep">
            <strong class="dib w-50">删除旧文件：</strong>
            <span class="substep">系统时钟</span>
          </li>
          <li class="substep">
            <strong class="dib w-50">检测文件1分钟没有变化：</strong>
            <span class="substep">系统时钟/单调时钟</span>
          </li>
        </ul>       
        <div class="notes markdown">
- 检测文件变化可以取**文件最后修改时间**，与**系统时钟**进行比较
- 也可以记录**检测到**最后一次变化到**单调时钟**，和当前单调时钟比较
- 前者可能受到文件服务器与应用服务器时钟不同步导致文件修改时间与当前系统时钟不同步的影响
        </div>
      </div>
      
      <!-- <div id="取时间的方法" class="step slide title box" data-rotate-z="80" data-x="-800" data-y="3000" data-goto-key-list="ArrowUp ArrowDown" data-goto-next-list="时间的应用 等待时间的方法"> -->
      <div id="取时间的方法" class="step slide title box" data-rel-to="时间的由来" data-rel-rotate-z="0" data-rel-x="0" data-rel-y="1.2h" data-goto-key-list="ArrowUp ArrowDown" data-goto-next-list="时间的应用 等待时间的方法">
          <h2>时间的应用</h2>
          <table class="borderless w-90">
            <tr>
              <td class="w-33">计算机怎样计时</td>
              <td class="w-33"><strong>取时间的方法</strong></td>
              <td class="w-34">等待时间的方法</td>
            </tr>
            <tr>
              <td class="w-33"></td>
              <td class="w-33 markdown">
- 直接读取TSC
- 系统调用
- C++标准库
- 交易系统
- 时钟的选择
              </td>
              <td class="w-34"></td>
            </tr>
          </table>
      </div>
      
      <div id="TSC" class="step markdown slide" data-rel-rotate-z="24" data-rel-x="2056.64" data-rel-y="437.15">
### 取时间的方法 —— TSC
      
某些 Intel 和 AMD 处理器包含一个 TSC 寄存器，以较高的速率增加，通常等于处理器时钟。此计数器的值可以通过 **RDTSC** 或 **RDTSCP** 计算机指令进行读取，以数十或数百个计算机周期提供非常低的访问时间和计算成本 —— 约为 10ns 级别

> The Time Stamp Counter **was once** an excellent high-resolution, low-overhead way for a program to get CPU timing information.  [Time Stamp Counter - Wikipedia](https://en.wikipedia.org/wiki/Time_Stamp_Counter)
      </div>
      
      <div id="TSC的问题" class="step markdown slide">
### TSC的问题

- 并非所有CPU都支持TSC
- 并非所有CPU的TSC都是固定频率的
  - 受节能策略影响，CPU频率可能会发生变化
  - RDMA测试时遇到这个问题
- 同一主板上不同CPU的TSC数值不保证一致
- 系统休眠之后恢复，TSC可能会被重置
- CPU乱序执行可能会影响``RDTSC``的准确性
      </div>
      
      <div id="高精度计时器" class="step markdown slide">
### 高精度计时器

- 微软[强烈建议](https://docs.microsoft.com/zh-cn/windows/win32/sysinfo/acquiring-high-resolution-time-stamps)不要直接使用``TSC``
  -  [QueryPerformanceCounter()](https://docs.microsoft.com/en-us/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter)（``QPC``）是最适合取高精度时间，度量时间的接口，避免了直接读取处理器[TSC](#TSC)的困难。配合[QueryPerformanceFrequency()](https://docs.microsoft.com/en-us/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency)使用
  - [GetSystemTimePreciseAsFileTime()](https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsystemtimepreciseasfiletime)可用于获取高精度UTC时间
- Linux上可以使用`clock_gettime(CLOCK_MONOTONIC_RAW)`
- 使用兼容性更好的``chrono::steady_clock``/``chrono::system_clock``
      </div>
      
      <div id="QueryPerformanceCounter" class="step slide">
        <div class="markdown">
### QueryPerformanceCounter - Windows

- 根据硬件的情况（有没有``TSC``及其特性）选取合适的时钟源
- 更新频率很多时候是``TSC``的1/1024
- 如果没有合适的``TSC``，开销变大
        </div>
        <pre><code class="lang-c font-smaller1">LARGE_INTEGER StartingTime, EndingTime, ElapsedMicroseconds;
LARGE_INTEGER Frequency;

QueryPerformanceFrequency(&Frequency); 
QueryPerformanceCounter(&StartingTime);

// Activity to be timed

QueryPerformanceCounter(&EndingTime);
ElapsedMicroseconds.QuadPart = EndingTime.QuadPart - StartingTime.QuadPart;

ElapsedMicroseconds.QuadPart *= 1000000;
ElapsedMicroseconds.QuadPart /= Frequency.QuadPart;</code></pre>
      </div>
      
      <div id="clock_gettime" class="step slide">
        <h3>clock_gettime() - Linux</h3>
        <pre><code class="lang-c">int clock_gettime(clockid_t clock_id, struct timespec *tp);
int clock_getres(clockid_t clock_id, struct timespec *tp);</code></pre>
        <div>
          不同的clock_id：
          <table class="borderless f2">
            <tr><th>CLOCK_REALTIME</th><td>系统时钟，受校时影响</td></tr>
            <tr><th>CLOCK_MONOTONIC</th><td>单调时钟，基于系统时钟，受NTP影响</td></tr>
            <tr><th>CLOCK_MONOTONIC_RAW</th><td>单调时钟，不受校时影响，基于TSC等硬件时钟</td></tr>
            <tr><th>CLOCK_REALTIME_COARSE</th><td>与CLOCK_REALTIME一样，但精度低（1ms？），开销小</td></tr>
            <tr><th>CLOCK_MONOTONIC_COARSE</th><td>与CLOCK_MONOTONIC一样，但精度低（1ms？），开销小</td></tr>
          </table>
          <div class="flex items-center">
            <div class="markdown">开销：</div>
            <div class="markdown f1">
- ``CLOCK_REALTIME``/``CLOCK_MONOTONIC``：几十ns
- ``CLOCK_MONOTONIC_RAW``：几百ns
            </div>
          </div>
        </div>
      </div>
      
      <div id="std::chrono" class="step markdown slide">
### std::chrono

- ``std::chrono::system_time``：系统时钟
- ``std::chrono::steady_clock``：单调时钟
- ``std::chrono::high_resolution_clock``：高精度时钟
  - ``std::chrono``提案人Howard Hinnant在[Stackoverflow](https://stackoverflow.com/a/37440647)上指出**不要使用**这个时钟
      </div>
      
      <div id="交易系统" class="step markdown slide more-text">
### 交易系统
      
- 取时延时间戳：**``cppf::sts::GetLatencyTimestamp()``**
  - 专用于发送时延采样，可能兼容``PTP``等手段
  - 不要用于其他处理
- 处理系统时间：**``cppf::common::util::DateTime``**
  - 可以取时区、进行时区转换
    - 支持UTC时区、本地时区（服务器时区）、接口时区（配置）
  - 适合用作业务时间
- 单调时钟：**``cppf::common::util::SteadyClock``**
  - 封装了``chrono::steady_clock``
  - 增加了测试模式，方便单元测试
  - 不可重演
  - 适合通信超时等逻辑
      </div>
      
      <div id="时钟的选择" class="step markdown slide font-smaller1">
### 时钟的选择

- 首选直接使用**``std::chrono``**
  - 取系统时间用**``system_clock``**
  - 取单调时间用**``steady_clock``**
- 平台相关的特殊需求
  - Linux：**``clock_gettime(CLOCK_REALTIME)``**或**``clock_gettime(CLOCK_MONOTONIC_RAW)``**
  - Windows: **``GetSystemTimePreciseAsFileTime()``**或**``QueryPerformanceCounter()``**，精度要求不高可以用``GetTickCount64()``
- 尽量避免直接用``TSC``
      </div>
      
      <div id="时钟精度越高越好？" class="step slide flex">
        <div class="markdown w-70 f1">
### 时钟精度越高越好？

- 时钟精度并不说明一切
  - 测量的精度取决于时钟精度与取时间的消耗
    - 3GHz的CPU，``TSC``的精度可以达到0.33纳秒，获取开销为十几纳秒到几百纳秒，总体精度只是后者
  - 时钟漂移影响更大
    - 出于成本考虑，PC和服务器上使用的晶振的偏差通常在**±30～50ppm**，极个别可能高达500ppm。
      **ppm**：``parts per million``，每百万单位允许的±偏差。
- 高精度可能带来高开销
        </div>
        <div class="w-30 self-center f2 tc">
          <h4><strong>10ppm</strong>对应测量误差</h4>
          <table class="striped">
            <tr><th>测量时段</th><th>累计偏差</th></tr>
            <tr><td>1 微秒</td><td>± 10 皮秒</td></tr>
            <tr><td>1 毫秒</td><td>± 10 纳秒</td></tr>
            <tr><td>1 秒</td><td>± 10 微秒</td></tr>
            <tr><td>1 小时</td><td>± 3.6 毫秒</td></tr>
            <tr><td>1 天</td><td>± 0.86 秒</td></tr>
            <tr><td>1 周</td><td>± 6.08 秒</td></tr>
          </table>
        </div>
      </div>
      
      <div id="双向报盘服务器时钟漂移事件" class="step slide font-smaller1">
        <div class="markdown">
### 双向报盘服务器时钟漂移事件
      
2012年6月19日双向报盘服务器DM16的时间发生漂移，到9:15时**漂移（慢了）约5秒多**。日志显示，服务器9:14:54:851628收到“允许报单”标志后，将随后587笔委托作为无效委托，做错单打回。

惠普维修工程师判断为**主板故障**，对主板进行了更换。

通信前端在早上启动时，与TANDEM进行校时，然后依据本地时间对接收到的委托进行检查。考虑到在途委托和时间漂移，通信前端留出了**5秒钟**的时间偏差，即9:14:55—15:00:05。如果收到的委托在此时间内即判断为合法，否则判断为非法。
        </div>
        <div class="notes markdown">
- 不应该在通信服务器各自独立用本地时间进行判断
- 提前5秒准入，留下干扰网关以提前报单影响公平性的可能
        </div>
      </div>

      <div id="时钟编程建议" class="step slide">
        <h3 class="w-100 tc">编程建议</h3>
        <div class="flex f1">
          <div class="w-60 markdown">
- 选取适当的值域
  - 时间类型建议用有符号类型，方便计算
  - **秒**：可能存在60秒（闰秒）
  - **时区**：精确到分钟
- 比较时间时，避免减法，防止正整数类型问题
  - ``now-begin&gt;=dur`` ⇒ ``now&gt;=begin+dur``
  - 时钟可能倒退，导致``now-begin &lt; 0``
  - 如果时钟为无符号类型，将得到很大的数值
          </div>
          <div class="w-40">
            <ul>
              <li>避免不必要的多次取时间：
                <ul>
                  <li>增加消耗</li>
                  <li>两次取值不同，出现非预期结果</li>
                </ul>
                <pre><code class="lang-c">if (now() - begin &lt; interval)
  sleep_for(begin + interval - now());</code></pre>
                <p class="substep"><code>begin+interval-now()</code>可能小于零</p>
              </li>
            </ul>
          </div>
        </div>
      </div>

      <div id="时钟编程建议2" class="step slide">
        <h3 class="w-100 tc">编程建议</h3>
        <h4>时钟不一定准，特别是跨计算机比较</h4>
        <div class="markdown">
- 可以用同步点计算时间差
  - 假定一条消息收发为同时或有合理的时延，计算时钟偏差
- 不同计算机时间流动不均匀，时间差可能正负波动
- 业务逻辑避免用本机时间
  - 不同机器不一致
  - 客户端有被干扰的可能
  - 交易系统用时钟源时间，以撮合判断为准
        </div>
        <div class="notes markdown">
- 最好避免用本地时间进行业务判断——双向通信机时钟漂移
- 由于用本地时间，需要留容忍度，留下影响敲门的可能性
        </div>
      </div>

      <div id="时钟编程建议3" class="step slide">
        <h3 class="w-100 tc">编程建议</h3>
        <h4>时钟可能归零</h4>
        <div class="markdown">
- GetTickCount()：约49.7天
  - 选择合适的API，如``GetTickCount64()``
  - 不直接比数值大小，假定时间差小于值域一半以判定先后
- 千年虫及``time_t``的2038问题
  - 选择合适的API
        </div>
      </div>

      <div id="时钟编程建议4" class="step slide">
        <h3 class="w-100 tc">编程建议</h3>
        <h4>正确使用时区</h4>
        <div class="flex justify-between items-begin">
          <div class="markdown w-60">
- 应用内部使用UTC，接口处进行转换
  - 可能需要使用用户终端的时区
  - 本地时间可能会跳变
    - 夏令时会导致时间重复或跳变
    - 有些地区会调整时区
          </div>
          <div class="markdown w-40">
- 用谁的时区？
  - 系统统一的时区
  - 服务器计算机时区
  - 客户端计算机时区
  - 用户可配置
          </div>
        </div>
        <div class="notes markdown">
- 不建议使用服务器时区，避免服务器时钟导致问题，简化配置基线管理
- 使用系统配置的时区进行业务处理
- 使用客户端时区可以提升易用性——邮件系统
        </div>
      </div>

      <div id="等待时间的方法" class="step slide title box" data-rel-to="取时间的方法" data-rel-rotate="0" data-rel-x="0" data-rel-y="1.2h" data-goto-key-list="ArrowUp ArrowDown" data-goto-next-list="取时间的方法 要点回顾">
          <h2>时间的应用</h2>
          <table class="borderless w-90">
            <tr>
              <td class="w-33">计算机怎样计时</td>
              <td class="w-33">取时间的方法</td>
              <td class="w-34"><strong>等待时间的方法</strong></td>
            </tr>
            <tr>
              <td class="w-33"></td>
              <td class="w-33"></td>
              <td class="w-34 markdown">
- 非独占等待
- 忙循环
- 编程建议
              </td>
            </tr>
          </table>
      </div>

      <div id="非独占等待" class="step slide markdown" data-rel-rotate-z="34" data-rel-x="2057.84" data-rel-y="629.14">
### 非独占等待
      
- 使用**``usleep()``**、**``this_thread::sleep_for()``**等方法。
- 等待期间不占用CPU
- 等待时间可能不准确
  - Windows一般是1/64秒（15.625毫秒）等倍数
  - 有API提升精度，但会导致计时漂移ms
- **适用于普遍情况**
      </div>

      <div id="双向小站时间漂移问题" class="step slide cf">
        <h3>20101220版本双向小站时间漂移问题</h3>

        <pre class="fr"><code class="lang-c">#define BUSINESS_TIME 50

While(1){
  timeBeginPeriod(1);
  Sleep(10);
  timeEndPeriod(1);
  Sleep(BUSINESS_TIME);
}</code></pre>

        <div class="markdown f1">
券商反映在升级到新版双向小站（版本号20101220）之后，机器本地时间会逐渐走快，但不影响正常交易报盘。早上小站与主站校时后，到中午闭市，本地时间快了45秒。换回升级前的小站程序（版本号20070118）问题消失。

问题原因定位到设置系统时间精度的两个函数**timeBeginPeriod** 和**timeEndPeriod**。

测试程序在各台机器上运行的五分钟内系统时间出现了5-20秒不等的偏移（时钟加快）。业务时间越长，则时钟偏差值会越大
        </div>
      </div>

      <div id="忙循环" class="step slide markdown">
### 忙循环
    
持续查询当前时间判断是否到达结束时间。

- 占用一个核
- 精度为时钟查询精度
- 可能受进程调度影响
- 适用于对精度要求高、等待时间短的情况
- 要选择合适的时钟
      </div>

      <div id="定时器编程建议" class="step markdown slide">
### 编程建议

- 等待时间可能长或短于预期时间
- 区分*每D时间处理一次*与*每**隔**D时间处理一次*
  - 前者的D时间包括处理时间
    - 从处理前开始计时
    - 需要考虑处理时间大于D的情况
    - 一般不能直接等待D时间
      </div>
      
      <div class="step slide skip hide-step"></div>
      
      <div id="要点回顾" class="step slide">
        <h3 class="tc">要点回顾</h3>
        <div class="flex justify-center f1">
          <div class="markdown w-60">
- 区分**系统时钟**与**单调时钟**
- ``C++``优先使用``chrono::system_clock``与``chrono::steady_clock``
- 交易系统
  - 时延时间戳： **``cppf::sts::GetLatencyTimestamp()``**
  - 系统时间： **``cppf::common::util::DateTime``**
  - 单调时钟： **``cppf::common::util::SteadyClock``**
          </div>
          <div class="markdown w-40">
- 内部使用**``UTC``**，边界处转换
- 北京时间``Asia/Shanghai``
- 选择正确的**类型**与**值域**
- 一个逻辑**避免多次取时间**
- 正确处理时间倒退、跳变
- 业务功能**不依赖**客户端时区与时间
          </div>
        </div>
      </div>
      
      <div id="参考资料" class="step markdown slide font-smaller2" data-goto-next="overview">
## 参考资料
- [获取高分辨率时间戳](https://docs.microsoft.com/zh-cn/windows/win32/sysinfo/acquiring-high-resolution-time-stamps)（[Acquiring high-resolution time stamps](https://docs.microsoft.com/en-us/windows/win32/sysinfo/acquiring-high-resolution-time-stamps)）
- [Time Stamp Counter - Wikipedia](https://en.wikipedia.org/wiki/Time_Stamp_Counter)
- [The Clock Mini-HOWTO: How Linux Keeps Track of Time](https://tldp.org/HOWTO/Clock-2.html)
- [A Foundation to Sleep On](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm)
- [计算机时间到底是怎么来的？程序员必看的时间知识！ | Kaito's Blog](http://kaito-kidd.com/2021/07/08/how-does-computer-time-come-from/)
- [System time - ArchWiki](https://wiki.archlinux.org/title/System_time)
- [人人都知道的时区，背后竟然有这么多奥秘-云社区-华为云](https://bbs.huaweicloud.com/blogs/detail/243151)
- [彻底弄懂GMT、UTC、时区和夏令时](https://zhuanlan.zhihu.com/p/135951778)
- [时区列表 - 维基百科，自由的百科全书](https://zh.m.wikipedia.org/wiki/%E6%97%B6%E5%8C%BA%E5%88%97%E8%A1%A8)
- [中国时区 - 维基百科，自由的百科全书](https://zh.m.wikipedia.org/wiki/%E4%B8%AD%E5%9C%8B%E6%99%82%E5%8D%80)
- [协调世界时 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6)
      </div>
      
      <div class="step slide title hide-step" data-rel-reset="all" data-scale="3" data-x="10000" data-y="1000">
        <h1>时延测试结果</h1>
      </div>
      
      <div id="等待0us测试结果" class="step slide f2 hide-step" data-rel-y="1h">
        <h3>等待0us测试结果</h3>
              
        <p>在10.132.37.206（RHEL 6）上测试，重复100次：</p>
        <p>代码见内网gitlab，cs/test_code</p>

        <pre><code>CPU is running at 2499.99 MHz, 0.400002 ns per cycle
Repeat 100 times

Expected 0 us, mean     9 ns, min    8 ns, max    10 ns, 90%    10 ns, CV  11.11%, with nop
Expected 0 us, mean 51533 ns, min 4384 ns, max 55440 ns, 90% 54262 ns, CV  16.60%, with usleep()
Expected 0 us, mean    10 ns, min    8 ns, max    23 ns, 90%    23 ns, CV  39.63%, with std::this_thread::sleep_for()
Expected 0 us, mean   264 ns, min  236 ns, max  2208 ns, 90%   249 ns, CV  74.01%, with BusyWaitChrono&lt;system_clock&gt;()
Expected 0 us, mean   257 ns, min  243 ns, max   737 ns, 90%   259 ns, CV  18.98%, with BusyWaitChrono&lt;steady_clock&gt;()
Expected 0 us, mean   246 ns, min  238 ns, max   368 ns, 90%   247 ns, CV   5.33%, with BusyWaitChrono&lt;high_resolution_clock&gt;()
Expected 0 us, mean    27 ns, min   26 ns, max    29 ns, 90%    29 ns, CV   3.83%, with BusyGetTSC()
Expected 0 us, mean    74 ns, min   64 ns, max   823 ns, 90%    68 ns, CV 102.66%, with clock_gettime(CLOCK_REALTIME)
Expected 0 us, mean    22 ns, min   16 ns, max   167 ns, 90%    22 ns, CV  68.35%, with clock_gettime(CLOCK_REALTIME_COARSE)
Expected 0 us, mean    71 ns, min   66 ns, max   290 ns, 90%    76 ns, CV  31.81%, with clock_gettime(CLOCK_MONOTONIC)
Expected 0 us, mean    25 ns, min   21 ns, max   210 ns, 90%    26 ns, CV  76.14%, with clock_gettime(CLOCK_MONOTONIC_COARSE)
Expected 0 us, mean   255 ns, min  244 ns, max   523 ns, 90%   256 ns, CV  11.09%, with clock_gettime(CLOCK_MONOTONIC_RAW)
        </code><pre>
      </div>
      
      <div id="等待1us测试结果" class="step slide f2 hide-step" data-rel-rotate-z="0" data-rel-x="0" data-rel-y="0.7h">
        <h3>等待1us测试结果</h3>
      
        <pre><code>CPU is running at 2499.99 MHz, 0.400002 ns per cycle
Repeat 100 times

Expected 1 us, mean      9 ns, min      8 ns, max      10 ns, 90%      10 ns, CV  11.18%, with nop
Expected 1 us, mean  54960 ns, min  35770 ns, max   65792 ns, 90%   56350 ns, CV   6.01%, with usleep()
Expected 1 us, mean  55410 ns, min  30386 ns, max   60493 ns, 90%   56776 ns, CV   5.27%, with std::this_thread::sleep_for()
Expected 1 us, mean   1306 ns, min   1155 ns, max   14872 ns, 90%    1181 ns, CV 104.37%, with BusyWaitChrono&lt;system_clock&gt;()
Expected 1 us, mean   1207 ns, min   1190 ns, max    1555 ns, 90%    1209 ns, CV   2.93%, with BusyWaitChrono&lt;steady_clock&gt;()
Expected 1 us, mean   1219 ns, min   1156 ns, max    6430 ns, 90%    1169 ns, CV  42.98%, with BusyWaitChrono&lt;high_resolution_clock&gt;()
Expected 1 us, mean   1029 ns, min   1023 ns, max    1034 ns, 90%    1034 ns, CV   0.46%, with BusyGetTSC()
Expected 1 us, mean   1060 ns, min   1044 ns, max    1615 ns, 90%    1062 ns, CV   5.32%, with clock_gettime(CLOCK_REALTIME)
Expected 1 us, mean 996445 ns, min 608426 ns, max 1391654 ns, 90% 1235119 ns, CV  19.36%, with clock_gettime(CLOCK_REALTIME_COARSE)
Expected 1 us, mean   1067 ns, min   1044 ns, max    1171 ns, 90%    1068 ns, CV   1.07%, with clock_gettime(CLOCK_MONOTONIC)
Expected 1 us, mean 998378 ns, min 616314 ns, max 1384229 ns, 90% 1033545 ns, CV  13.04%, with clock_gettime(CLOCK_MONOTONIC_COARSE)
Expected 1 us, mean   1210 ns, min   1198 ns, max    1408 ns, 90%    1212 ns, CV   1.77%, with clock_gettime(CLOCK_MONOTONIC_RAW)
        </code><pre>
      </div>
      
      <div id="等待2us测试结果" class="step slide f2 hide-step" data-rel-y="0.5h">
        <h3>等待2us测试结果</h3>
              
        <pre><code>CPU is running at 2499.99 MHz, 0.400002 ns per cycle
Repeat 100 times

Expected 2 us, mean      9 ns, min      8 ns, max      14 ns, 90%      10 ns, CV 12.47%, with nop
Expected 2 us, mean  54972 ns, min  19146 ns, max   77643 ns, 90%   56541 ns, CV 10.82%, with usleep()
Expected 2 us, mean  55246 ns, min  27143 ns, max   80903 ns, 90%   57504 ns, CV  7.95%, with std::this_thread::sleep_for()
Expected 2 us, mean   2158 ns, min   2133 ns, max    3290 ns, 90%    2151 ns, CV  5.33%, with BusyWaitChrono&lt;system_clock&gt;()
Expected 2 us, mean   2225 ns, min   2186 ns, max    2567 ns, 90%    2232 ns, CV  1.60%, with BusyWaitChrono&lt;steady_clock&gt;()
Expected 2 us, mean   2224 ns, min   2133 ns, max    9948 ns, 90%    2157 ns, CV 34.91%, with BusyWaitChrono&lt;high_resolution_clock&gt;()
Expected 2 us, mean   2032 ns, min   2026 ns, max    2034 ns, 90%    2034 ns, CV  0.08%, with BusyGetTSC()
Expected 2 us, mean   2060 ns, min   2047 ns, max    2658 ns, 90%    2061 ns, CV  2.93%, with clock_gettime(CLOCK_REALTIME)
Expected 2 us, mean 994512 ns, min 471108 ns, max 1394528 ns, 90% 1347994 ns, CV 20.53%, with clock_gettime(CLOCK_REALTIME_COARSE)
Expected 2 us, mean   2053 ns, min   2049 ns, max    2166 ns, 90%    2054 ns, CV  0.60%, with clock_gettime(CLOCK_MONOTONIC)
Expected 2 us, mean 997366 ns, min 624954 ns, max 1361290 ns, 90% 1154957 ns, CV 13.35%, with clock_gettime(CLOCK_MONOTONIC_COARSE)
Expected 2 us, mean   2195 ns, min   2178 ns, max    2364 ns, 90%    2199 ns, CV  0.85%, with clock_gettime(CLOCK_MONOTONIC_RAW)
        </code><pre>
      </div>
      
      <div id="等待10us测试结果" class="step slide f2 hide-step">
        <h3>等待10us测试结果</h3>
              
        <pre><code>CPU is running at 2499.99 MHz, 0.400002 ns per cycle
Repeat 100 times

Expected 10 us, mean      9 ns, min      7 ns, max      12 ns, 90%      10 ns, CV 11.79%, with nop
Expected 10 us, mean  62596 ns, min  24570 ns, max   77347 ns, 90%   64518 ns, CV 11.96%, with usleep()
Expected 10 us, mean  63933 ns, min  46970 ns, max   79494 ns, 90%   65629 ns, CV  4.83%, with std::this_thread::sleep_for()
Expected 10 us, mean  10218 ns, min  10141 ns, max   11531 ns, 90%   10278 ns, CV  1.36%, with BusyWaitChrono&lt;system_clock&gt;()
Expected 10 us, mean  10171 ns, min  10133 ns, max   10538 ns, 90%   10201 ns, CV  0.44%, with BusyWaitChrono&lt;steady_clock&gt;()
Expected 10 us, mean  10180 ns, min  10136 ns, max   11041 ns, 90%   10211 ns, CV  0.88%, with BusyWaitChrono&lt;high_resolution_clock&gt;()
Expected 10 us, mean  10063 ns, min  10024 ns, max   13788 ns, 90%   10027 ns, CV  3.72%, with BusyGetTSC()
Expected 10 us, mean  10092 ns, min  10055 ns, max   11583 ns, 90%   10072 ns, CV  1.64%, with clock_gettime(CLOCK_REALTIME)
Expected 10 us, mean 991051 ns, min 125851 ns, max 1380647 ns, 90% 1003108 ns, CV 11.24%, with clock_gettime(CLOCK_REALTIME_COARSE)
Expected 10 us, mean  10101 ns, min  10047 ns, max   12849 ns, 90%   10076 ns, CV  2.74%, with clock_gettime(CLOCK_MONOTONIC)
Expected 10 us, mean 999335 ns, min 615538 ns, max 1382725 ns, 90% 1217447 ns, CV 15.34%, with clock_gettime(CLOCK_MONOTONIC_COARSE)
Expected 10 us, mean  10201 ns, min  10131 ns, max   11507 ns, 90%   10227 ns, CV  1.34%, with clock_gettime(CLOCK_MONOTONIC_RAW)
        </code><pre>
      </div>
      
      <div id="等待100us测试结果" class="step slide f2 hide-step">
        <h3>等待100us测试结果</h3>
              
        <pre><code>CPU is running at 2499.99 MHz, 0.400002 ns per cycle
Repeat 100 times

Expected 100 us, mean      9 ns, min      8 ns, max      12 ns, 90%      10 ns, CV 11.21%, with nop
Expected 100 us, mean 154220 ns, min 112983 ns, max  160977 ns, 90%  156056 ns, CV  3.24%, with usleep()
Expected 100 us, mean 155330 ns, min 147830 ns, max  169184 ns, 90%  155875 ns, CV  1.07%, with std::this_thread::sleep_for()
Expected 100 us, mean 100379 ns, min 100163 ns, max  114399 ns, 90%  100308 ns, CV  1.40%, with BusyWaitChrono&lt;system_clock&gt;()
Expected 100 us, mean 100180 ns, min 100137 ns, max  100493 ns, 90%  100242 ns, CV  0.05%, with BusyWaitChrono&lt;steady_clock&gt;()
Expected 100 us, mean 100215 ns, min 100138 ns, max  100301 ns, 90%  100250 ns, CV  0.04%, with BusyWaitChrono&lt;high_resolution_clock&gt;()
Expected 100 us, mean 100090 ns, min 100024 ns, max  106118 ns, 90%  100036 ns, CV  0.61%, with BusyGetTSC()
Expected 100 us, mean 100070 ns, min 100044 ns, max  101163 ns, 90%  100064 ns, CV  0.11%, with clock_gettime(CLOCK_REALTIME)
Expected 100 us, mean 994428 ns, min 465340 ns, max 1394699 ns, 90% 1378966 ns, CV 22.75%, with clock_gettime(CLOCK_REALTIME_COARSE)
Expected 100 us, mean 100068 ns, min 100045 ns, max  100208 ns, 90%  100069 ns, CV  0.02%, with clock_gettime(CLOCK_MONOTONIC)
Expected 100 us, mean 999414 ns, min 605541 ns, max 1395542 ns, 90% 1000168 ns, CV  7.59%, with clock_gettime(CLOCK_MONOTONIC_COARSE)
Expected 100 us, mean 100206 ns, min 100136 ns, max  100363 ns, 90%  100237 ns, CV  0.03%, with clock_gettime(CLOCK_MONOTONIC_RAW)
        </code><pre>
      </div>
      
      <div id="overview" class="step slide noskip" data-x="0" data-y="0" data-scale=14 data-rotate=0 data-goto-prev="参考资料">
        <div id="signature" class="absolute right-0 bottom-0 center">
          <p>Powered by <a href="http://impress.js.org">impress.js<sup>*</sup></a></p>
        </div>
      </div>

    </div> <!-- #impress -->

    <div id="impress-toolbar"></div>

    <div class="impress-progressbar"><div></div></div>
    <div class="impress-progress"></div>

    <div id="impress-help"></div>

    <script src="impress.js/extras/highlight/highlight.pack.js" charset="utf-8"></script>
    <script src="impress.js/extras/markdown/markdown.js" charset="utf-8"></script>
    <script src="impress.js/js/impress.js" charset="utf-8"></script>
    <script charset="utf-8">
      impress().init();
      var hideSteps = document.querySelectorAll( '.hide-step' );
      for ( var i = 0; i < hideSteps.length; i++ ) {
        impress().lib.util.triggerEvent( hideSteps[i], "impress:navigation-ui:hideStep" );
      }
    </script>
    <script src="vendor/inlineSVG.min.js" charset="utf-8"></script>
    <script charset="utf-8">inlineSVG.init();</script>
  </body>
</html>
<!-- vim: set fenc=utf-8 sw=2 ft=html.impressjs: -->
