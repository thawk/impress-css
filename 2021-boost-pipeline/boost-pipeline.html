<!doctype html>
<html lang="zh-cmn-Hans">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Pipeline框架</title>
    <!-- <link href="css/typo.css" rel="stylesheet" /> -->
    <link href="css/basscss.css" rel="stylesheet" />
    <link href="impress.js/css/impress-common.css" rel="stylesheet" />
    <link href="css/fonts.css" rel="stylesheet" />
    <link href="css/classic-slides.css" rel="stylesheet" />
    <link href="impress.js/extras/highlight/styles/default.css" rel="stylesheet" />
  </head>
<body class="impress-not-supported">
<div class="fallback-message">
  <p>您正在使用的浏览器<b>不支持</b>impress.js需要的功能，因此只能看到简化版本。</p>
  <p>请使用最新版本的<b>Chrome</b>、<b>Safari</b>或<b>Firefox</b>浏览器以取得最佳效果。</p>
</div>

<div id="impress" class="typo nodebug" data-width="1920" data-height="1080" data-autoplay="0" data-max-scale="4">

<!-- title页放到其他页上面，避免在overview页面上被遮挡 -->
<div id="title" class="step slide title" data-x="0" data-y="0" data-z=1100>
  <h1>Boost.Pipeline框架</h1>
</div>

<div id="简介" class="step slide markdown" data-rel-x="0" data-rel-y="1080" data-rotate=0 data-z=1000>

## 简介

* 源代码: https://github.com/erenon/pipeline
* 文档: http://erenon.hu/pipeline/
* C++ Pipeline implementation based on [N3534 - C++ Pipelines](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3534.html). Development of this library is founded by Google through the GSoC 2014 program.

-----

### 头文件

    #include &lt;boost/pipeline.hpp&gt;
    namespace ppl = boost::pipeline;

### 样例

    boost::pipeline::thread_pool pool;
    std::vector&lt;std::string&gt; output;

    // 流程划分为若干Segment，Segment间以|连接
    auto execution =                    
      (boost::pipeline::from(input)     // 输入
        | trim                          // 变换
        | grep_error
        | [] (const std::string&amp; input) { return "-&gt; " + input; }
        | output                        // 输出
      ).run(pool);
</div>

<div id="输入" class="step slide markdown title">
## **输入** | 变换 | 变换… | 输出
</div>

<div class="step slide markdown">
### 数据源

生成输入数据流。

* container/range
  - 过程中不能变化
* queue
  - 线程安全，可以动态调整
* generator
  - 函数
  - functor

-----

### 管道开端

使用``from()``函数：

    ppl::from(container)                          // takes begin and end
    ppl::from(container.begin(), container.end()) // same as above
    ppl::from(queue)                              // reference is taken
    ppl::from(generator)                          // generator gets copied
</div>

<div id="变换" class="step slide markdown title">
## 输入 | **变换** | 变换… | 输出
</div>

<div class="step slide markdown">
从输入产生若干输出。

### 变换函数的四种形式

    Output one_to_one(const Input&amp; input);
    Output n_to_one  (queue_front&lt;Input&gt;&amp; upstream);
    R      one_to_n  (const Input&amp; input,           queue_back&lt;Output&gt;&amp; downstream);
    R      n_to_m    (queue_front&lt;Input&gt;&amp; upstream, queue_back&lt;Output&gt;&amp; downstream);

* 对于``n_to_m()``，如果是用``bind()``产生的，其返回值``R``的类型必须是输出类型``Output``，以便框架获知输出类型。
</div>

<div id="输出" class="step slide markdown title">
## 输入 | 变换 | 变换… | **输出**
</div>

<div class="step slide markdown">
### 三种输出形式

``pipeline``库可以自动识别是否输出Segment

* a container
* a queue
* a consumer
  * **``void``** ``consumer_a(queue_front<int> upstream);``

-----

### 调用方式

    void consumer_a(queue_front<int> upstream); // returns void
    int  consumer_b(queue_front<int> upstream); // returns int, might be mistaken for an n-to-one transformation

    segment | container; // container is recognized as output, taken by reference
    segment | queue;     // same as above
    segment | consumer_a // definitely a consumer, gets copied
    segment | ppl::to(consumer_b) // `to()` must be used to be recognized as consumer
</div>

<div id="运行" class="step slide markdown title">
## (输入 | 变换 | 变换… | 输出) → **运行**
</div>

<div class="step slide markdown">
**计划（plan）**: 完整、带输入和输出的Segment序列。

以``thread_pool``为参数调用``plan``的``run()``方法

    ppl::thread_pool pool{4}; // add 4 threads to the pool
    ppl::execution exec = (
      ppl::from(input) | mod_seven | even_only | add_two | output
    ).run(pool);
    exec.wait(); // blocks until the pipeline is finished
    bool done = exec.is_done(); // done == true
</div>

<div id="杂项" class="step slide markdown title">
## 杂项
</div>

<div class="step slide markdown">
## 开放片段（Open Segments）

不完整（左边或右边没有终结）的片段。

左边开放的片段需要使用``make()``生成。

    auto s2 = ppl::make(length) | output;
    auto s1 = ppl::from(lines) | trim;
    auto s  = s1 | s2;

-----
## 对传递类型的要求

* T must be **default constructible**
* T must be **movable**
* T must be **move assignable**

-----
## 数据流分叉

    ppl::queue<request> priority_queue;
    ppl::queue<request> non_priority_queue;

    auto split = std::bind(
      split_by_priority,
      std::ref(priority_queue),
      std::ref(non_priority_queue),
      _1
    );

    auto reader = ppl::from(generate_requests) | split; // 这是开放片段

    // 利用queue手工连接上下游
    auto priority_processor = priority_queue | parse_request | request_id | to_stdout;
    auto processor      = non_priority_queue | parse_request | request_id | process_later;
      ppl::thread_pool pool{8};

    auto exec1 = reader.run(pool);
    auto exec2 = priority_processor.run(pool);
    auto exec3 = processor.run(pool);

    exec1.wait();

    priority_queue.close();
    non_priority_queue.close();

    exec2.wait();
    exec3.wait();
</div>

<div class="step slide markdown">
</div>

<div id="代码解析" class="step slide markdown title">
# 代码解析
</div>

<div class="step slide">
    <div class="markdown font-smaller2">
* **callable**: A function pointer, function object, functor, bind expression or lambda. Basically, every f is a callable if f(Args...) is valid for some Args....
* **transformation**: A method producing output items from input items. Precisely, it's a callable which signature matches to one of them described in section Transformations
* **segment**: A not necessarily terminated series of connected transformations.
* **plan**: A terminated series of connected transformations: its input and output is specified.
* **task**: A running segment. Tasks are scheduled on the thread pool.
* **upstream**: Generally, the segment connected to the left of a segment. Specifically, it's the input queue of a task.
* **downstream**: Generally, the segment connected to the right of a segment. Specifically, it's the output queue of a task.
    </div> 
</div> 

<div class="step slide markdown">
* 由接收方创建``queue``，在``segment::run()``中传给前一个``segment``的``run()``，由后往前启动
* 以``one_one_segment``或``n_one_segment``，令``Output``类型为``terminated``（``void``）表示最终环节
* 每个``segment``都有对应的``task``类型，在``segment::run()``中提交线程池
* ``one_one_segment``和``n_one_segment``视``Output``类型是否为``terminated``，可以对应两种``task``
  - ``one_one_task``/``single_consume_output_task``
  - ``n_one_task``/``multiple_consume_output_task``
</div>

<div class="step slide markdown">
![](images/class-diagram.drawio.svg)
</div>

<div id="overview" class="step slide skip" data-x="200" data-y="200" data-scale=5 data-rotate=360>
  <div id="signature" class="absolute right-0 bottom-0 center">
    <p>Power by <em><a href="http://impress.js.org">impress.js<sup>*</sup></a></em></p>
  </div>
</div>

</div> <!-- #impress -->

<div id="impress-toolbar"></div>

<div class="impress-progressbar"><div></div></div>
<div class="impress-progress"></div>

<div id="impress-help"></div>

<script src="impress.js/extras/highlight/highlight.pack.js" charset="utf-8"></script>
<script src="impress.js/extras/markdown/markdown.js" charset="utf-8"></script>
<script src="impress.js/extras/mermaid/mermaid.min.js" charset="utf-8"></script>
<script src="impress.js/js/impress.js" charset="utf-8"></script>
<script charset="utf-8">impress().init();</script>
<script charset="utf-8">
  // 为所有<code>设置语言为cpp，防止highlight.js自动检测失败
  var codes = document.querySelectorAll( "code" );
  for (var i = 0; i < codes.length; i += 1 ) {
    codes[i].classList.add('language-cpp');
  }
</script>
</body>
</html>
