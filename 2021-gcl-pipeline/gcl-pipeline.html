<!doctype html>
<html lang="zh-cmn-Hans">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <title>C++ Pipeline</title>
    <link href="css/tachyons.min.css" rel="stylesheet" />
    <link href="impress.js/css/impress-common.css" rel="stylesheet" />
    <link href="css/fonts.css" rel="stylesheet" />
    <link href="css/classic-slides.css" rel="stylesheet" />
    <link href="impress.js/extras/highlight/styles/default.css" rel="stylesheet" />
    <style type="text/css" media="screen">
#title {
    opacity: 0.1;
}
.impress-on-title #title {
    opacity: 1;
}
.impress-on-title .step {
    opacity: 0;
}
    </style>
  </head>
<body class="impress-not-supported">
<div class="fallback-message">
  <p>您正在使用的浏览器<b>不支持</b>impress.js需要的功能，因此只能看到简化版本。</p>
  <p>请使用最新版本的<b>Chrome</b>、<b>Safari</b>或<b>Firefox</b>浏览器以取得最佳效果。</p>
</div>

<div id="impress" class="nodebug" data-width="1920" data-height="1080" data-autoplay="0" data-max-scale="4">

<!-- title页放到其他页上面，避免在overview页面上被遮挡 -->
<div id="title" class="step slide title" data-x="1100" data-y="3000" data-z=-5000 data-scale=10>
  <h1>GCL Pipeline</h1>
</div>

<div id="简介" class="step slide markdown" data-x="-1000" data-y="-2800" data-rotate=30 data-z=1000>

## 简介

* [N3534 - C++ Pipelines](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3534.html) 的参考实现
* ``Google Concurrency Library``的一部分
  * http://code.google.com/p/google-concurrency-library/source/browse/include/pipeline.h
* https://github.com/cyfdecyf/google-concurrency-library
</div>

<div id="样例" class="step slide markdown" data-rel-x="-540" data-rel-y="936" data-rotate=30>
### 样例

    (pipeline::from(input_queue) |
      bind(grep, "^Error") |
      bind(vgrep, "test@example.com") |
      bind(sed, "'s/^Error:.*Message: //") |
      output_queue).run(&amp;threadpool);

[//]: # (分割两个代码块)
      
    void grep(const string&amp; re, queue_back&lt;string&gt; in, queue_front&lt;string&gt; out)
    { // 输入和输出都是队列（n:m）
      string item;
      while (in.wait_pop(item) == queue_op_status::success) {
        if (re::match(re, item)) {
          out.push(item);
    }}}

[//]: # (分割两个代码块)

    void grep(const string&amp; re, string item, queue_front&lt;string&gt; out)
    { // 输入是字符串，输出是队列（1:n）
      if (re::match(re, item)) {
        out.push(item);
      }
    }

[//]: # (分割两个代码块)
      
    void sed(const string&amp; re, queue_back&lt;string&gt; in, queue_front&lt;string&gt; out)
    { // 输入和输出都是队列（n:m）
      string item;
      while (in.wait_pop(item) == queue_op_status::success) {
        re::apply(re, item);
        out.push(item);
      }
    }

[//]: # (分割两个代码块)
      
    string sed(const string&amp; re, string item)
    { // 输入和输出都是字符串（1:1）
      re::apply(re, item);
      return item;
    }
</div>

<div id="grep" class="step slide" data-rel-x="-150" data-rel-y="260" data-rotate="30">
</div>

<div id="sed" class="step slide" data-rel-x="-250" data-rel-y="433" data-rotate="30">
</div>

<div id="处理多文件样例" class="step slide markdown" data-rel-x="-540" data-rel-y="936" data-rotate=30>
### 多个文件

    void read_file(const string&amp; filename, queue_front&lt;string&gt; out) {
      File file(filename);
      for (string line : file.readLines()) {
        out.push(line);
      }
    }

[//]: # (分割两个代码块)
      
    queue&lt;string&gt; filenames = ...;

    pipeline::execution task(
      pipeline::from(filenames) |
      read_file | grep_fn | vgrep_fn | sed_fn |
      output_queue, &amp;thread_pool);
</div>

<div id="并发执行" class="step slide markdown" data-rel-x="-540" data-rel-y="936" data-rotate=30>
### 并发执行

    pipeline::execution task(
      pipeline::from(filenames) |
      pipeline::parallel(read_file | grep_fn | vgrep_fn | sed_fn, 8) |
      output_queue).run(&amp;thread_pool);

[//]: # (分割两个代码块)
      
    pipeline::execution task(
      pipeline::from(filenames) |
      pipeline::parallel(read_file | grep_fn, 8) |
      vgrep_fn | sed_fn |
      output_queue).run(&amp;thread_pool);
</div>

<div id="抽象" class="step slide markdown title" data-rel-x="0" data-rel-y="1920" data-rotate="-90">
## Pipeline Abstractions
</div>

<div id="segment" class="step slide markdown" data-rel-x="1080" data-rel-y="0" data-rotate="-90">
### Pipeline Segments

* 包含一系列已经连接的操作
* 不能单独执行

[//]: # ()

    pipeline::segment&lt;string, string&gt; s1 = pipeline::from(grep_fn) | vgrep_fn | sed_fn;
    pipeline::segment&lt;string, int&gt; s2 = ...
    pipeline::segment&lt;string, int&gt; s3 = s1 | s2;

-----

### 创建segment

    // 几种不同的处理函数，1:1/n:1/1:n/n:m
    string direct_fn(int input);
    string queue_in_fn(queue_back&lt;int&gt; input_queue);
    void queue_out_fn(int input, queue_front&lt;string&gt; output_queue);
    void queue_in_out_fn(queue_back&lt;int&gt; input_queue, queue_front&lt;string&gt; output_queue);

[//]: # ()

    // Segment类型只和输入、输出有关
    pipeline::segment&lt;int, string&gt; s1;

[//]: # ()

    // 使用不同处理函数创建相同的Segment类型
    s1 = pipeline::make(direct_fn);         // 1:1
    s1 = pipeline::make(queue_in_fn);       // n:1
    s1 = pipeline::make(queue_out_fn);      // 1:n
    s1 = pipeline::make(queue_in_out_fn);   // n:m

[//]: # ()

    // Segment可以只终结一端，此时不能单独执行，需要终结另一端才行
    pipeline::segment&lt;pipeline::terminated, Name&gt; s3 = pipeline::from(source_queue) | s2;
    pipeline::plan p3 = s3 | process_name_queue;
</div>

<div id="创建segment2" class="step slide" data-rel-x="300" data-rel-y="0" data-rotate="-90">
</div>

<div id="plans" class="step slide markdown" data-rel-x="1080" data-rel-y="0" data-rotate="-90">
### Pipeline Plans

* 包含输入和输出
* 可以单独执行

[//]: # ()

    // 使用队列作为输入
    pipeline::plan plan = pipeline::from(input_queue) | s1 | output_queue;

[//]: # ()

    void read_file(const string&amp; filename, queue_front&lt;string&gt; out) {
      File file(filename);
      for (string line : file.readLines()) {
        out.push(line);
      }
    }
    // 使用函数作为输入
    pipeline::plan plan = pipeline::produce(bind(read_file, "log.txt") | s1 | output_queue;

-----

### Plan是两端都终结的Segment


    typedef segment&lt;terminated, terminated&gt; plan;

* 输入端：一个``queue``或写入到``queue_front``的函数
* 输出端：一个``queue``、一个从``queue_back``读取内容的函数或者处理输出的函数

[//]: # ()

    // Sources
    void write_ints(queue_front&lt;int&gt; output_queue) {
      for(...) {
        output_queue.push(n);
      }
    }

    queue&lt;int&gt; source_queue;

[//]: # ()

    // Sinks
    queue&lt;Name&gt; name_output_queue;

    void process_name_queue(queue_back&lt;Name&gt; input_queue) {
    }

    void process_name(Name input) {
    }

[//]: # ()

    pipeline::plan p1 = pipeline::from(source_queue) | s2 | name_output_queue;
    pipeline::plan p2 = pipeline::from(source_queue) | s2 | process_name;
    pipeline::plan p3 = pipeline::from(write_ints)   | s2 | process_name_queue;
</div>

<div id="plans2" class="step slide" data-rel-x="600" data-rel-y="0" data-rotate="-90">
</div>

<div id="executions" class="step slide markdown" data-rel-x="1080" data-rel-y="0" data-rotate="-90">
### Pipeline Executions

* 一次执行

[//]: # ()

    pipeline::execution execn = plan.run(&amp;threadpool);
    if (execn.is_done()) ...
    execn.wait();
</div>

<div id="类图概览" class="step" data-rel-x="1080" data-rel-y="-1920" data-rotate="-180">
    <h2 class="absolute left-0">主要类</h2>
    <div class="mermaid">
classDiagram
    class execution {
      execution(__instance* inst)
      bool is_done()
      void wait()
    }
    execution *-- __instance

    class __instance {
      __instance(simple_thread_pool* pool, __segment_base~terminated, terminated~* p)

      bool is_done()
      wait()
      thread_start()
      thread_done()
      execute(function~void ()~ func)
      size_t all_threads_done()
    }

    __instance o-- simple_thread_pool

    class __segment_base~IN, OUT~ {
      clone() 
      void run(__instance* inst, queue_back~OUT~ out_queue) 
      queue_back~IN~ get_back()
      bool can_merge_on_front()
      bool can_merge_on_back()
      void merge_on_front(queue_front~IN~ in_queue)
      queue_front~OUT~ merge_back()
    }

    __segment_base~IN, OUT~ <|-- __segment_producer~OUT~
    __segment_base~IN, OUT~ <|-- __segment_queue_producer~OUT~
    __segment_base~IN, OUT~ <|-- __segment_function~IN, OUT~
    __segment_base~IN, OUT~ <|-- __segment_consumer~IN~
    __segment_base~IN, OUT~ <|-- __segment_queue_consumer~IN~
    __segment_base~IN, OUT~ <|-- __segment_chain~IN, MID, OUT~
    __segment_base~IN, OUT~ <|-- __segment_parallel~IN, OUT~

    class segment~IN, OUT~:::main_class {
      execution run(simple_thread_pool* pool);
    }
    segment~IN, OUT~ "base_" *-- __segment_base~IN, OUT~
    __instance o-- segment~IN, OUT~

    cssClass "execution,segment" main_class
    </div>
</div>

<div id="segment类" class="step slide" data-rel-x="0" data-rel-y="-50" data-rotate="-180" data-scale="0.4">
    <div class="notes markdown">``segment``类是核心，通过``impl``模式把具体内容保存在``__segment_base``中</div>
</div>

<div id="segment子类1" class="step slide" data-rel-x="370" data-rel-y="-120" data-rotate="-180" data-scale="0.4">
    <div class="notes markdown">有两个生产类，一个中间类，两个消费类</div>
</div>

<div id="segment子类2" class="step slide" data-rel-x="-740" data-rel-y="0" data-rotate="-180" data-scale="0.4">
    <div class="notes markdown">还有用于连接两个环节的类，以及并发处理的类</div>
</div>

<div id="instance类" class="step slide" data-rel-x="420" data-rel-y="300" data-rotate="-180" data-scale="0.5">
    <div class="notes markdown">``segment::run()``返回``execution``对象，通过``__instance``类引用线程池并持有``plan``实例</div>
</div>

<div id="主要方法" class="step slide markdown font-smaller2" data-rel-to="class_digram" data-rel-x="0" data-rel-y="-1080" data-rotate="-180">
### 主要方法
* **``from()``** → ``segment&lt;terminated, OUT&gt;``
  - ``queue``/``queue_front``/``void (queue_back&lt;OUT&gt;)&gt;``
* **``make()``** → ``segment&lt;IN, OUT&gt;``
  - ``OUT(IN)``/``OUT(queue_front&lt;IN&gt;)``
  - ``void(IN, queue_back&lt;OUT&gt;)``
  - ``void (queue_front&lt;IN&gt;, queue_back&lt;OUT&gt;)``
* **``to()``** → ``segment&lt;IN, terminated&gt;``
  - ``void (IN)``/``queue_back&lt;IN&gt;``/``queue``
* **``parallel``**``(segment&lt;IN, OUT&gt;, int n)`` → ``segment&lt;IN, OUT&gt;``
* **``operator|``** → ``segment&lt;IN, OUT&gt;``
</div>

<div id="实现细节" class="step slide markdown" data-rel-x="0" data-rel-y="-1080" data-rotate="-180">
* 只为``segment&lt;terminated, terminated&gt;``实现了``run()``，防止用户对普通``segment``调用``run()``
* 每个``segment``都有单独的线程，总数不能大于线程池的最大线程数（通过``class simple_thread_pool``构造函数指定）
* ``class __instance``构造时就启动处理
  ``plan_-&gt;run(this, queue_back&lt;terminated&gt;(dummy_queue_));``

-----

* 对``parallel()``包装的``segment``，会创建``n``个副本，同时运行；另外创建一个线程**依次**从各副本收集结果
  - 如果每个``segment``有``m``个线程，一个``paralle()``共需要``n*m+1``个线程，**需要保证线程池够大**
  - 对每个副本创建一个大小为``10``对输出队列，用于缓存输出。**貌似如果结果数大于``n*10``就会死锁**
</div>

<div id="一些思考" class="step slide markdown" data-rel-x="-1500" data-rel-y="400" data-rotate="-270">
## 思考

* ``1:1``和``1:n``的``segment``可以用推的方式，但``n:1``和``n:m``的``segment``需要用拉的方式，因此使用每个``segment``一个线程的方式
  - 对于单输入的``segment``，理论上可以不用独立线程，直接在前一环节线程执行即可
  - 可以考虑使用协程代替线程
</div>

<div id="overview" class="step slide skip" data-x="0" data-y="0" data-scale=8 data-rotate=0>
  <div id="signature" class="absolute right-0 bottom-0 center">
    <p>Power by <em><a href="http://impress.js.org">impress.js<sup>*</sup></a></em></p>
  </div>
</div>

</div> <!-- #impress -->

<div id="impress-toolbar"></div>

<div class="impress-progressbar"><div></div></div>
<div class="impress-progress"></div>

<div id="impress-help"></div>

<script src="impress.js/extras/highlight/highlight.pack.js" charset="utf-8"></script>
<script src="impress.js/extras/markdown/markdown.js" charset="utf-8"></script>
<script src="impress.js/js/impress.js" charset="utf-8"></script>
<script charset="utf-8">impress().init();</script>
<script src="impress.js/extras/mermaid/mermaid.min.js" charset="utf-8"></script>
<script charset="utf-8">
  if (window.mermaid) {
    mermaid.initialize({
      flowchart:{
        useMaxWidth:false
      },
      class:{
        useMaxWidth:false
      },
      theme: 'neutral',
      startOnLoad:true
    });
  }
</script>
<script charset="utf-8">
  // 为所有<code>设置语言为cpp，防止highlight.js自动检测失败
  var codes = document.querySelectorAll( "code" );
  for (var i = 0; i < codes.length; i += 1 ) {
    codes[i].classList.add('language-cpp');
  }
</script>
</body>
</html>
