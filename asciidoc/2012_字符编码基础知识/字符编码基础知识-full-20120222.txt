= 字符编码基础知识
:Author: 研发部 谭浩通
:Date: 2012-02
:slidebackground: frontpage
:numbered:

ifdef::backend-slidy2[:slidebackground: content]
== 字符集与字符编码

ifdef::backend-slidy2[]
include::slidybackgrounds.txt[]
endif::backend-slidy2[]

ifdef::backend-slidy2[>>>]

=== 基础知识

ifdef::backend-slidy2[>>>]

==== 字符编码的几个概念

计算机中储存的信息都是用二进制数表示的；而我们在屏幕上看到的英文、汉字等字符是二进制数转换之后的结果。

维基百科中的 http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81[“字符编码”] 词条提到下列概念：

* **字符集（Character Set）**
+
是一个系统支持的所有抽象字符的集合。字符表可以是封闭的，不允许添加新的符号；字符表也可以是开放的，即允许添加新的符号（Unicode和一定程度上代码页是这方面的例子）。
+
如：ASCII字符集中包含的128个字符，GB2312-80字符集中收录了6763个字符。

ifdef::backend-slidy2[<<<]

* **编码字符集（CCS:Coded Character Set）**
+
是一个将**字符集**C映射到非负整数N的函数。N是一个有限的集合，其中的每个数字叫做**码点**，但某些码点可能没有被对应的字符。
+
例如，在一个给定的字符表中，表示大写拉丁字母“A”的字符被赋予整数65、字符“B”是66，如此继续下去。多个编码字符集可以表示同样的字符表，例如ISO-8859-1和IBM的代码页037和500含盖同样的字符表但是将它们映射为不同的代码。
+
UNICODE、UCS-2、UCS-4、GB2312、GB18030都是编码字符集。

ifdef::backend-slidy2[<<<]

* **字符编码表（CEF:Character Encoding Form）**
+
定义将**编码字符集**的整数代码转换成有限大小整数代码值以利于使用固定位的二进制表示数字的形式。例如，使用16位单元存储数字信息的系统每个单元只能够直接表示从0到65,535的数值，但是如果使用多个16位单元就能够表示更大的整数。
+
** 最简单的字符编码表就是单纯地选择足够大的单位，以保证编码字符集中的所有数值能够直接编码（一个码点对应一个码值）。如传统非CJK编码（8位），或早期版本的Unicode（16位）。这种情况下，字符编码表就等于编码字符集。
+
** 随着编码字符集的大小增加，很多系统都使用变长的编码，如UTF-8、UTF-16。
+
UTF-8、UTF-16、UTF-32都对应到相同的编码字符集，但使用的固定位数分别为8位、16位、32位。

ifdef::backend-slidy2[<<<]

* **字符编码方案（CES:Character Encoding Scheme）**
+
定义如何将整数代码对应到适合基于8位字节数据的文件系统存储或用于网络传输。
+
多数使用Unicode的场合，使用BOM（Byte Order Mark）来指定字节顺序是大端序或者小端序。
+
UTF-16LE、UTF-16BE。

==== 代码页（Code page）

* **代码页**是字符集编码的别名，也有人称"内码表"。

* 早期的操作系统直接使用BIOS供应的VGA功能来显示字符，只能支持一套字符
编码。BIOS支持的编码被称为OEM代码页。图形操作系统使用自己字符呈现引擎
，可以支持很多不同的字符集编码。

* 早期IBM和微软内部使用特别数字来标记这些编码，现在虽然这些编码大都有
自己的名称了，但很多微软程序还使用这些数字来指定编码。

* 常见代码页

** CP437：原始的 IBM PC 代码页
** CP936：简体中文，微软的CP936通常被视为等同GBK
** CP950：繁体中文（大五码）
** CP1200：UCS-2LE Unicode 小端序
** CP1201：UCS-2BE Unicode 大端序
** CP65001：UTF-8 Unicode

==== 字节序（Endian）

image::images/egg.jpg[float="left"]

“endian”一词来源于乔纳森·斯威夫特的小说格列佛游记。小说中，小人国为水煮蛋该从大的一端（Big-End）剥开还是小的一端（Little-End）剥开而争论，争论的双方分别被称为Big-endians和Little-endians。

ifdef::backend-slidy2[<<<]

[frame="none",grid="none",options="autowidth"]
|==========
| image:images/big-endian.png[] |
**大端序（big-endian）**的最高有效位（MSB, Most Significant Byte）是0x0A 存储在最低的内存地址处。下一个字节0x0B存在后面的地址处。正类似于十六进制字节从左到右的阅读顺序。
| image:images/little-endian.png[] |
**小端序（little-endian）**的最低有效位（LSB,Least Significant Byte）是0x0D 存储在最低的内存地址处。后面字节依次存在后面的地址处。
|==========

ifdef::backend-slidy2[<<<]

* 不同处理器体系支持不同的字节序：

** x86，MOS Technology 6502，Z80，VAX，PDP-11等处理器为Little endian。
** Motorola 6800，Motorola 68000，PowerPC 970，System/370，SPARC（除V9外）等处理器为Big endian
** ARM, PowerPC (除PowerPC 970外), DEC Alpha, SPARC V9, MIPS, PA-RISC, IA64的字节序是可配置的。

* 网络传输一般采用大端序，也被称之为**网络字节序**，或**网络序**。IP协议中定义大端序为网络字节序。
+
NOTE: 伯克利socket API定义了一组转换函数，用于16和32bit整数在网络序和本机字节序之间的转换。++htonl++，++htons++用于本机序转换到网络序； ++ntohl++，++ntohs++用于网络序转换到本机序。

=== 几种常见字符编码

ifdef::backend-slidy2[>>>]

==== ASCII

ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语。

* **ASCII字符集**
+
主要包括控制字符（回车键、退格、换行键等）；可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 

* **ASCII编码**
+
将ASCII字符集转换为计算机可以接受的数字系统的数的规则。使用7位（bits）表示一个字符，共128字符；但是7位编码的字符集只能支持128个字符，为了表示更多的欧洲常用字符对ASCII进行了扩展，ASCII扩展字符集使用8位（bits）表示一个字符，共256字符。

image::images/charset-ascii.png[align="center"]

==== GBXXXX系列

ifdef::backend-slidy2[>>>]

===== GB2312

GB 2312 或 GB 2312-80 是中国国家标准简体中文字符集，全称《信息交换用汉字编码字符集·基本集》，又称GB0，由中国国家标准总局发布，1981年5月1日实施。

GB2312共收录6763个汉字，覆盖中国大陆99.75%的使用频率

GB2312规定：

* 一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字；
* 前面的一个字节（称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样就可以组合出大约7000多个简体汉字。
* 数学符号、罗马希腊的 字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的"全角"字符，而原来在127号以下的那些就叫"半角"字符。

//image::images/charset-GB2312.gif[align="center"]

===== GBK

GBK即**汉字内码扩展规范**。

1993年，Unicode 1.1版本推出，收录中国大陆、台湾、日本及韩国通用字符集的汉字，总共有20,902个。中国大陆订定了等同于Unicode 1.1版本的“GB 13000.1-93”“信息技术通用多八位编码字符集（UCS）第一部分：体系结构与基本多文种平面”。

由于GB 2312-80只收录6763个汉字，有不少汉字并未有收录在内，于是厂商微软利用GB 2312-80未使用的编码空间，收录GB 13000.1-93全部字符制定了GBK编码。

最早实现于Windows 95简体中文版。虽然GBK收录GB 13000.1-93的全部字符，但编码方式并不相同。

NOTE: GBK自身并非国家标准，只是曾由国家技术监督局标准化司、电子工业部科技与质量监督司公布为“技术规范指导性文件”。原始GB13000一直未被业界采用，后续国家标准GB18030技术上兼容GBK而非GB13000。

NOTE: GBK的第二字节使用了0x40至0x7E的范围，由于这个范围内包含一些特殊字符（如“|”、“\”），因此可能会被一些程序误处理。由于保持与GBK的兼容性，GB18030也有同样的问题。


===== GB18030

GB 18030，最新版本为GB 18030-2005，其全称为中华人民共和国国家标准GB 18030-2005《信息技术 中文编码字符集》，与GB 2312-1980完全兼容，与GBK基本兼容，支持GB 13000及Unicode的全部统一汉字，共收录汉字70244个。

GB18030有以下特点：

* 与 UTF-8 相同，采用多字节编码，每个字可以由1个、2个或4个字节组成。
** 单字节部分使用0x00至0x7F码位。
** 双字节部分采用两个字节表示一个字符，其首字节码位从0x81至0xFE，尾字节码位分别是0x40至0x7E和0x80至0xFE。
** 四字节部分，第一个字节的编码为0x81至0xFE；第二个字节的编码范围为0x30至0x39；第三个字节编码范围为0x81至0xFE；第四个字节编码范围为0x30至0x39。
* 编码空间庞大，最多可定义161万个字符。（能表示所有Unicode码点，其映射关系一部分要通过查表得出，一部分可以通过算法求出）
* 支持中国国内少数民族的文字，不需要动用造字区。
* 汉字收录范围包含繁体汉字以及日韩汉字

==== Unicode

ifdef::backend-slidy2[>>>]

===== Unicode的由来

Unicode（统一码、万国码、单一码、标准万国码）是计算机科学领域里的一项业界标准，用以统一地呈现和处理世界上大部分的文字系统，并为其编码。

传统字符编码方案的主要缺陷：

* 由于不同的系统采用不同的字符编码，导致多个系统间难以进行数据交换。
* 由于不同字符编码方案可能使用相同的编码区间，同一个数值在不同编码方案中有不同的含义，因此电脑系统难以同时支持多语种。

为解决传统字符编码的问题，制定了一个国际标准，叫做Unicode。Unicode为每个字符提供了唯一的特定数值，不论在什么平台上、不论在什么软件中，也不论什么语言。也就是说，它世界上使用的所有字符都列出来，并给每一个字符一个唯一特定数值。

Unicode一般使用U+hhhh的方式表示。如U+6731就是“朱”字。

===== Unicode的录入

* 很多输入法都支持Unicode字符
* 通常可以通过字符映射表之类的程序，直接从屏幕上选择所需的字符
** Windows下在开始－运行中，输入charmap即可打开“字符映射表”程序
** Mac OS X/GNOME/KDE都有相应的工具程序
* Windows的RTF控件（包括在写字版程序及Word中），有两种输入Unicode字符的方式：
** 输入字符对应的4位16进制Unicode编码，再按++Alt-X++
** 按住++Alt++键不放，在小键盘上输入字符对应的10进制编码，放开++Alt++键
* 在Vim中，先输入Ctrl-V，然后按字母v，再输入4位16进制Unicode字符编码
* 在GTK+程序，如GNOME中，可以先按++Ctrl-Shift-u++，放开，再输入4位16进制Unicode编码，再按++Enter++键

===== UCS与Unicode

通用字符集（Universal Character Set，UCS）是由ISO制定的ISO 10646（或称ISO/IEC 10646）标准所定义的标准字符集。

Unicode则是由统一码联盟（英语：The Unicode Consortium）（主要由来自多个国家政府和各大软件商的代表参与）制定。

UCS和Unicode最初是不同的标准，1991年前后，两个项目的参与者都认识到，世界不需要两个不兼容的字符集。于是，它们开始合并双方的工作成果，并为创立一个单一编码表而协同工作。两个项目独立地公布各自的标准，但双方都同意保持两者标准的码表兼容，并紧密地共同调整任何未来的扩展。

===== UCS-2与UCS-4

目前的Unicode字符分为17组编排，每组称为平面（Plane），而每平面拥有65536（即 216）个代码点。然而目前只有少数平面被使用。

其中，基本多文种平面（Basic Multilingual Plane, BMP），或称第零平面或零号平面（Plane 0），是Unicode中的一个编码区段。编码从U+0000至U+FFFF。

在早期阶段，Unicode只支持BMP，最多16位，也称为UCS-2。在引入辅助平面后，需要21位（不足3字节）才能表示所有字符，实际上仍然占用4字节编码区间，这就是UCS-4。

===== UTF

Unicode只是一种编码字符集（CCS:Coded Character Set），定义字符与编码之间的关系。但在实际应用中，还需要定义怎样传输Unicode编码，这就是Unicode 转换格式（Unicode Transformation Format，简称为**UTF**）。

目前常用的Unicode实现方式：

* UTF-8：变长编码，每个字符使用一到四个字节。基本7位ASCII字符仍用7位编码表示，占用一个字节（首位补0），汉字等大部分常用字使用3个字节。
* UTF-16：变长编码，对于BMP平面内的字符使用两个字节，对于其它平面的字符使用四个字节。根据字节顺序，又可以分为UTF-16 LE和UTF-16 BE。Windows和Linux中，默认为UTF-16 LE。
+
UTF-16是UCS-2的超集，UCS-2只能使用2字节编码，而UTF-16是为2字节或4字节的变长编码。通常如果一个软件声称能支持UCS-2，往往暗示其不能支持UTF-16 中超过2字节的部分。

NOTE: 在Windows记事本程序中，“另存为”对话框可以选择四种编码，ANSI为非Unicode编码（对应于当前系统内码，如GBK），其余三种为“Unicode”（对应UTF-16 LE）、“Unicode big endian”（对应UTF-16 BE）和“UTF-8”

ifdef::backend-slidy2[<<<]

其它Unicode实现方式 footnote:[参见维基百科中的“Unicode”词条]

* UTF-7：可以应用在电子邮件传输之类的应用
* Punycode：根据RFC 3492标准而制定的编码系统,主要用于把域名从地方语言所采用的Unicode编码转换成为可用于DNS系统的编码。
* CESU-8
* SCSU
* UTF-32：等同于UCS-4
* GB18030

===== UTF-8 vs UCS-2

.UTF-8

* 优点

** 完美兼容ASCII（0x00到0x7F）。

** Linux的内核是UTF-8的，意味着在Linux下使用UTF-8有得天独厚的优势。而且不仅仅是Linux，大量的开源计划（由于大部分开源计划都是围绕着Linux走的），包括网页，XML等也都是原生UTF-8的，可参考源程序范例更多。

** 单字节编码，不用考虑大头小头的字节序问题。

** 自同步，可以轻易识别字符的开始及字符占用的字节数。

* 缺点

** 大量的组合字符（即用两个以上字节来表示一个字符），使得字符串的处理很不方便。

** 以非ASCII字符为主的数据在存储时，占用空间较大。

ifdef::backend-slidy2[<<<]

.UCS-2

* 优点

** 统一定长编码，都是两个字节对应一个字符，所以对于字符串的处理非常方便。没有变长的痛苦。大量的宽字节C/C++函数都可以直接使用。

** Windows的内核是UTF-16的，但是由于UCS-2仅仅是UTF-16的一个子集，所以在Windows下使用UCS-2，有得天独厚的优势。另外，从资料上看，使用UTF-16/UCS-2的操作系统阵营比使用UTF-8的更加庞大。

* 缺点

** 在 Unix 下使用 UCS-2 (或 UCS-4) 会导致非常严重的问题. 用这些编码的字符串会包含一些特殊的字符, 比如 '\0' 或 '/', 它们在 文件名和其他 C 库函数参数里都有特别的含义. 另外, 大多数使用 ASCII 文件的 UNIX 下的工具, 如果不进行重大修改是无法读取 16 位的字符的. 基于这些原因, 在文件名, 文本文件, 环境变量等地方, UCS-2 不适合作为 Unicode 的外部编码。

=== Wide character/宽字符

宽字符（Wide character）是程序设计的术语。它是一个含糊的术语，用以表示比8位字符还宽的数据类型。

C/C\++中，以++wchar_t++类型表示宽字符。

==== 宽字符 vs MBCS/多字节字符集

C标准中，

* MBCS指的是使用固定或可变数量的字节来表示单个字符。一个字符占用多个逻辑单元。

* 宽字符指的是在**程序运行过程中**通过**一个**对象来表达**一个**字符。一个字符占用一个逻辑单元。
+
(Wide characters) which are run-time representations of characters in single objects

==== 宽字符 vs Unicode

* 宽字符只表示不小于8位的字符（在C/C++标准中，只要求wchar_t的大小不小于8
位），并没有规定使用何种字符编码。

* 在很多程序设计语言中，宽字符中存放的是Unicode数值。

* 由于受以前使用UCS-2的影响，Win 32/Win 64 API以及Java/.Net Framework都把宽字符的大小定义为16位，采用UTF-16编码。

* 类Unix系统一般把宽字符的大小定义为32位，采用UTF-32编码。

== 涉及字符编码的Linux环境设置

ifdef::backend-slidy2[>>>]

=== LC_ALL、LC_*、LANG等不同变量的含义

POSIX系统中有12个LC_*变量，分别设置语言环境的不同方面，还可以设置 LC_ALL，该设置将覆盖这12项LC_*设置。

另外，如果这些LC_*，LC_ALL都没有设置的话，系统将使用LANG变量中的值作为缺省值。

NOTE: 优先级的关系：LC_ALL > LC_* >LANG

ifdef::backend-slidy2[<<<]

12个LC_*变量的具体含义如下：

[cols="4*",options="autowidth"]
|==========
| LC_CTYPE | 语言符号及其分类。决定系统的内码。
| LC_NUMERIC | 数字
| LC_COLLATE | 比较和排序习惯
| LC_TIME | 时间显示格式
| LC_MONETARY | 货币单位
| LC_MESSAGES | 信息。主要是提示信息,错误信息,状态信息,标题,标签,按钮和菜单等
| LC_NAME | 姓名书写方式
| LC_ADDRESS | 地址书写方式
| LC_TELEPHONE | 电话号码书写方式
| LC_MEASUREMENT | 度量衡表达方式 
| LC_PAPER | 默认纸张尺寸大小
| LC_IDENTIFICATION | 对locale自身包含信息的概述
|==========

=== 设置区域环境的方法

image::images/linux_locale.png[float="right"]

.Linux

* 通过++locale++命令可以查看上述LC_*，LANG等变量的状态

* 设置整个环境为简体中文UTF-8环境：
+
[source,sh]
---------------------------------------------------------------------
export LC_ALL=zh_CN.UTF-8
---------------------------------------------------------------------

* 把内码设置UTF-8，其它环境保持不变：
+
[source,sh]
---------------------------------------------------------------------
export LC_CTYPE=zh_CN.UTF-8
---------------------------------------------------------------------

ifdef::backend-slidy2[<<<]

image::images/win7_locale.png[float="right"]

.Windows

* 可以通过“控制面板”——“区域和语言”——“管理”——“更改系统区域设置”进行修改

== 关于C++程序的字符编码问题

ifdef::backend-slidy2[>>>]

=== 编程过程中涉及的几种字符编码

ifdef::backend-slidy2[>>>]

==== C++源文件的编码

* 指的是C++源程序文件（.cpp/.h）本身使用什么字符编码（GB18030/UTF-8等）。

* 通常在简体中文Windows环境下，各种编辑器（包括Visual Studio）新建文件
的缺省编码都是GB18030，所以不特别指定的话，Windows环境下C++源文件的编
码通常为GB18030。

* 而在Linux环境下，最常使用，也是推荐使用的是UTF-8编码。

==== C++程序的内码

* 编译后，C++中的字符串常量都会变成一串字节存放在可执行文件中。这个内
码指的就是在可执行文件中，字符串以什么编码进行存放。这里的字符串常量指
的是窄字符（char）而非宽字符（wchar_t）。宽字符通常是以Unicode（VC 使
用UTF-16，gcc使用UTF-32）存放。

* 一般来说，我们常用的简体中文版VC所使用的内码是GB18030，而gcc/g++使用
的内码缺省是utf-8，但可以通过-fexec-charset参数进行修改。
+
  NOTE: 可以通过在程序中打印字符串每个字节十六进制形式来判断程序所使用的内码。

==== 运行环境编码

* 指的是执行程序时，操作系统或终端所使用的编码。程序中输出的字符最终要
转换为运行环境编码才能正确显示，否则就会出现乱码。

* 我们常用的简体中文版Windows的环境编码是GB18030，而Linux下最常用的环境
编码是UTF-8。

NOTE: Linux下，通过环境变量++LC_CTYPE++可以改变终端所使用的字符编码。
Windows下也可以通过控制面板中，“区域与语言”进行相应的设置。 

==== 这几个编码之间的关系

源程序需要由编译器编译为目标文件，目标文件运行后输出信息到终端，因此这
几个编码之间存在一定的关联：

[cols="literal,default",separator="!",frame="none",grid="none",options="autowidth"]
|==========
!
  源程序  ----------源文件编码
    | 编译器编译
 目标文件 ----------程序内码
    | 运行后输出信息
   输出   ----------运行环境编码
!
* 编译器需要正确识别源文件的编码，把源文件编译为目标文件，并把源文件中
的以源文件编码的字符串转换为以程序内码编制的字符串保存在目标文件中。

* C++标准库需要正确识别终端的运行环境编码，并把程序的输出转换为运行环
境所使用的编码，以便正确显示。

|==========

NOTE: 当源文件的字符编码与程序内码都是UTF-8时（gcc的缺省情况），gcc似
乎并不会对源文件中的字符编码进行转换，而是直接把字符串原样存放到目标文
件中，在这种情况下，源程序中的GB18030编码的字符串在输出时仍然为GB18030
编码。但如果在其它源文件字符编码的实际值与编译选项不同时，会在编译时报
无法从XXX转换到UTF-8的错，因此还不清楚为什么两个编码都是UTF-8时，
GB18030 编码的源文件能通过编译。

=== 源文件应该采用什么编码？

ifdef::backend-slidy2[>>>]

==== 不同编译器支持不同的源文件编码 

* gcc (v4.3.2 20081105): footnote:[参见 http\://stackoverflow.com/questions/688760/how-to-create-a-utf-8-string-literal-in-visual-c-2008 ]
** 支持UTF-8编码的源文件，UTF-8编码的源文件**不能**有BOM。
** 根据 http://gcc.gnu.org/bugzilla/show_bug.cgi?id=33415 ，似乎gcc
   4.4.0 开始支持带BOM的UTF-8文件。

NOTE: gcc提供了-finput-charset参数可以指定源文件的字符编码，但由于标准
头文件都是ascii编码的，因此如果要引用标准头文件的话，源代码的编码必须
兼容ascii，这实际上限制了使用UTF-16作为源文件编码。vc未能找到类似的选项。

ifdef::backend-slidy2[<<<]

* vc2003:
** 支持UTF-8编码的源文件，可以有BOM，也可以没有。

* vc2005+:
** 支持UTF-8编码的源文件，**必须有**BOM。
** 支持UTF-16LE/UTF-16BE的源文件，可以有也可以没有BOM。

==== 源文件是否使用非ascii字符

* 源代码中只使用ascii字符

** C/C++代码中只使用ascii字符，如果有非ascii字符可以用\xHH或\uXXXX表示。
注释中建议使用utf-8编码。

** 由于目前大部分的字符编码都兼容ascii，因此不存在编码选择问题。

** 如果需要支持多语言，可以通过http://www.gnu.org/software/gettext/[gettext]
、http://www.boost.org/libs/locale/index.html[Boost.Locale]或类似的库，把非
ascii字符串放到单独的语言文件中，实现多语言支持。

* 源代码中使用中文等非ascii字符

** 在实践中，由于\xHH或\uXXXX等方式很不直观，容易出错且不好维护。

** 未必所有程序都需要支持多语言，因此未必想引入gettext或类似的解决方案。

==== 源文件的编码选择

* UTF-8

** Unicode是解决多语言问题的最好选择，而UTF-8由于与ASCII兼容，也是最通
用的Unicode编码方式。

** 从上面的资料中可见，各编译器对UTF-8编码的支持不一样

*** 低版本的gcc不允许有BOM
*** vc2005以上要求必须有BOM
*** 高版本的gcc允许有也允许没有BOM

** 如果需要兼容低版本gcc和高版本的vc，就无法使用UTF-8作为源程序字符编码

** 如果只需要支持gcc 4.4.0以上版本，可以使用带BOM的UTF-8编码。

ifdef::backend-slidy2[<<<]

* UTF-16

** VC支持UTF-16LE/UTF-16BE，有或没有BOM。
** gcc要求程序中include的头文件所用编码与程序编码一致，由于系统头文件均为ascii
编码，不兼容UTF-16，因此在gcc下编译出错。

ifdef::backend-slidy2[<<<]

* GB18030

** 我们一般都在简体中文Windows下工作，在vc下可以直接编译
** 在gcc下也可以通过增加编译选项-finput-charset=gb18030进行编译
** 根据维基百科中GB18030 的词条内容，GB18030 is a superset of ASCII
and can represent the whole range of Unicode code points（GB18030向后
兼容ASCII，并且能表示所有的 Unicode码点），因此使用GB18030有足够的表达
能力，可以表示所有的Unicode 字符。
** 使用GB18030的唯一缺点就是在非简体中文版本的VC下，由于无法指定源文件
的编码，因此有可能无法正确识别此编码的源文件。

=== 应该使用什么程序内码？

ifdef::backend-slidy2[>>>]

==== 窄字符

* char/strlen/string/cout
* 不同的编译器下有不同的缺省编码（简体中文vc是GB18030，gcc是UTF-8）
* C++在输出窄字符时会按程序内码原样输出，不会进行编码转换
** 要求程序内码与运行环境编码一致，这样才不会出现乱码
*** 简体中文版vc的程序内码是GB18030，使用窄字符只能运行在GB18030环境下
*** gcc缺省使用UTF-8作为程序内码，使用窄字符只能运行在UTF-8的终端环境下

NOTE: 这里说的都是在源代码中直接写中文等非ascii字符的程序。用前面提到
的gettext及其它工具，使用窄字符的程序也可以在不同编码的运行环境中正确
输出中文

==== 宽字符

* wchar_t/wcslen/wstring/wcout
* 一般使用Unicode，其中vc下使用UTF-16，gcc缺省使用UTF-32。
* C++在输出宽字符时会自动转换为运行环境的编码，因此只要正确设置了运行
环境编码，同一个程序就可以在不同编码的运行环境中正确显示中文
** 类似于Java/.Net。Java/.Net的字符串类型都使用Unicode，在输入/输出时
都需要与当前运行环境的编码进行互转。

NOTE: 宽、窄字符的终端输出（cout/wcout）不要混用，否则容易出现乱码或字
符丢失的问题。因此，如果程序用到的库中使用了窄字符终端流输出功能（
cin/cout/cerr/clog等），最好避免使用宽字符，以免出现问题。

=== 运行环境应该用什么字符编码？

* 使用窄字符和使用宽字符的程序对运行环境的字符编码有不同要求

** 使用宽字符，只要在程序中正确设置当前环境的字符编码（一般通过
++locale::global(locale(""))++ 进行设置），C++标准库会在输入、输出时正
确进行字符编码转换，因此可以适应各种编码的运行环境。

** 使用窄字符，但程序中不出现非ascii字符的话，对运行环境没有特别要求，
可以适应各种编码的运行环境。

** 使用窄字符，程序中也直接使用汉字等非ascii字符的话，由于C++标准库会把
目标文件中保存的字符串（以程序内码保存）直接输出，不会进行字符编码转换
，因此要求运行环境的编码与程序内码一致。即简体中文VC编译的程序只能运行
在GB18030环境下，gcc编译的程序只能运行在UTF-8环境下（可以在编译时通过
-fexec-charset参数进行修改）。

=== C++源文件编码的选择

ifdef::backend-slidy2[>>>]

==== 几种可行做法

* 使用窄字符，源程序中只使用ascii字符，非ascii字符，如中文等通过
gettext等工具放到单独的语言包中。
** 这种做法比较多人推荐。
** 程序中不能直接出现非ascii字符，也不能通过\uXXXX方式指定非ascii字符
** 不需要考虑源程序文件的编码问题。
** 注释中可以使用ascii兼容的编码，不影响编译器。
** 有比较多的现成代码可供重用。
** 兼容VC及gcc各版本。
** 兼容各种编码的运行环境。

ifdef::backend-slidy2[<<<]

* 使用窄字符，源程序中允许使用非ascii字符。
** 要求运行环境的编码与程序内码一致，即只支持GB18030编码的Windows及
UTF-8编码的Linux。
** 根据源程序使用的编码不同，对编译器的兼容性也不同：
... 使用窄字符，源程序使用带BOM的UTF-8编码。
*** 兼容VC各语种的各版本。
*** 兼容gcc 4.4.0以上版本。
... 使用窄字符，源程序使用GB18030编码。
*** 兼容VC的简体中文各版本。
*** 兼容gcc各版本，但在编译时需要加上-finput-char=gb18030参数。

ifdef::backend-slidy2[<<<]

* 使用宽字符，源程序中允许使用非ascii字符。
** 兼容各种编码的运行环境，能正确输出中文。
** 根据源程序使用的编码不同，对编译器的兼容性也不同：
... 使用窄字符，源程序使用带BOM的UTF-8编码。
*** 兼容VC各语种的各版本。
*** 兼容gcc 4.4.0以上版本。
... 使用窄字符，源程序使用GB18030编码。
*** 兼容VC的简体中文各版本。
*** 兼容gcc各版本，但在编译时需要加上-finput-char=gb18030参数。
** 由于以前使用宽字符的程序比较少，可供重用的代码较少。

NOTE: 如果程序中需要一些固定字符编码的字符串常量，例如固定是GB18030
编码的字符串常量，这些常量应该以\xXX的方式存放字符串常量经GB18030编码
后的内容，这样的内容才不会被转换为程序的内码，也不会转换为运行环境编码
。

==== 推荐做法

* 根据我们的现状，对于需要支持多语种的程序，建议使用窄字符，源程序中只
使用ascii字符。利用++gettext++/++Boost.Locale++等库提供多语种支持。

* 对于不需要支持多语种的程序，考虑到重用已有的代码，可以考虑使用窄字符
，采用GB18030编码，但只能运行在GB18030编码的Windows环境及UTF-8编码的
Linux环境下。

== C++编程相关问题

ifdef::backend-slidy2[>>>]

=== 根据用户环境自动设置编码

* C程序
+
[source,cpp]
--------------------
#include <locale.h>
setlocale(LC_CTYPE, "");
--------------------

* C++程序
+
[source,cpp]
--------------------
#include <locale>
std::locale::global(std::locale(""));
--------------------

NOTE: 执行了C++初始化后，就不需要再执行C的初始化。

=== 窄字体、宽字符、UTF-8之间互转

image::images/cxx-charset-convert.png[align="center"]

=== 用户输入、输出及持久化

由于用户输入、输出及从文件、网络等设施读写的数据在程序底层看来都是字节
流，因此存在在输入时如何把这些字节流解释成有效的信息，在输出时怎么把程
序中的信息转换为正确的字节流的问题。

* 程序本身不需要处理这些数据
** 只是把数据从一个来源搬到另一个地方（如把用户输入保存到文件，或者从一个流读入，写到另一个流等）
** 输入的字符编码与输出的字符编码一致的话
** 程序不需要对数据进行任何编码转换，只需要把读入的数据按原样写到输出
即可，数据的字符编码与程序的编码没有关系。
+
** 比如网站应用程序，只需要保证用户页面使用UTF-8编码，数据库、数据文
件也都使用UTF-8编码，那么用户输入的数据可以直接写入数据库及数据文件，
从数据库或数据文件中读取的数据也可以直接展现给用户，不需要进行编码转换
。

ifdef::backend-slidy2[<<<]

* 程序需要在一定程度上对数据进行处理（如需要判断字符个数、对字符进行比
较、在字符串上附加或去掉内容）
** 需要把数据转换为一种明确的字符编码，一般来说是程序内码，再进行处理
，在处理后再转换为所需的字符编码进行输出。

*** 对于宽字符程序，如果只需要处理采用当前运行环境字符编码的数据，可以
通过++locale::global()++指定io流的字符编码，在输入、输出时C\++标准库
会自动在当前运行环境编码与程序内码之间进行编码转换。如果不使用流的话，
也可以通过标准的++wcstombs()++或++mbstowcs()++函数进行当前编码（通过
++locale::global()++或++setlocale()++指定）与宽字符之间的转换。

*** 对于窄字符程序，如果数据的字符编码与程序内码一致也不需要进行编码转
换，直接处理即可。

*** 对于其它情形，需要引入++iconv++/++Boost.Locale++或类似的字符编码转
换库，以便实现不同字符编码之间的转换。

=== gettext、iconv的替代品

* ++gettext++及++iconv++都属于GNU Project，考虑到版权因素，并非所有程
序，特别是商业程序，都适合使用这些库。

* 在Boost 1.48.0中，正式发布Boost.Locale库，该库提供了++gettext++、
++iconv++的功能，并在此基础上进行了增强

** 大小写变换
** 字符顺序比较
** 时间的处理 
** 分词
** 数字的格式化输入/输出
** 消息格式化
** 多语种支持
** 字符编码转换

==== Boost.Locale示例

ifdef::backend-slidy2[>>>]

===== 流输入、输出
[source,cpp]
--------------------
cout << as::currency << 123.45 << endl;
// display 123.45 in local currency representation.
cin >> as::currency >> x ;
// Parse currency representation and store it in x


time_t now=time(0);
cout << "Today is "<< as::date << now << " and tomorrow is " << now+24*3600 << endl;
cout << "Current time is "<< as::time << now << endl;
cout << "The current weekday is "<< as::ftime("%A") << now << endl;
--------------------

===== 多语言支持

.源程序foo.cpp
[source,cpp]
--------------------
cout << translate("Hello World") << endl;
--------------------

.从源程序生成foo.po
[source,sh]
--------------------
xgettext --keyword=translate:1,1t --keyword=translate:1,2,3t dir.cpp
--------------------

--------------------
...
msgid "Hello World"
msgstr ""
...
--------------------
    
ifdef::backend-slidy2[<<<]

.翻译foo.po
--------------------
...
msgid "Hello World"
msgstr "שלום עולם"
...
--------------------
    
.生成foo.mo
--------------------
de
de/LC_MESSAGES
de/LC_MESSAGES/foo.mo
en_CA/
en_CA/LC_MESSAGES
en_CA/LC_MESSAGES/foo.mo
...
--------------------

===== 格式化++boost::locale::format++

[source,cpp]
--------------------
cout << format(translate("Today {1,date} I would meet {2} at home")) % time(0) % name <<endl;
--------------------

NOTE: 比++boost::format++增加了区域相关的支持，如对日期、时间、货币等
的复杂格式化

== 相关内容

ifdef::backend-slidy2[>>>]

=== 几个单词

i18n:: Internationalization，国际化。指在设计软件，将软件与特定语言及地区脱钩的过程。当软件被移植到不同的语言及地区时，软件本身不用做内部工程上的改变或修正。

L10n:: Localization，本地化。指当移植软件时，加上与特定区域设置有关的信息和翻译文件的过程。使用大写的L以利区分i18n中的i。

g11n:: Globalization，全球化。微软及IBM等企业中，会使用全球化一词来作为国际化和本地化两者的合称


=== HTTP头中，与字符编码有关的部分

在HTTP中，与字符集和字符编码相关的消息头是Accept-Charset/Content-Type，另外还有一些容易混淆的消息头：

* Accept-Charset：浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）；

* Accept-Encoding：浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）；

* Accept-Language：浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等；

* Content-Type：WEB服务器告诉浏览器自己响应的对象的类型和字符集。例如：Content-Type: text/html; charset='gb2312'

* Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzip

* Content-Language：WEB服务器告诉浏览器自己响应的对象的语言。 

== 参考资料

字符编码:: http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81
Unicode:: http://zh.wikipedia.org/wiki/Unicode
UTF-16:: http://zh.wikipedia.org/wiki/UCS-2
Unicode字符平面映射:: http://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84
GBK:: http://zh.wikipedia.org/wiki/GBK
代码页:: http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A0%81%E9%A1%B5
Wide character:: http://en.wikipedia.org/wiki/Wide_character
区域设置:: http://zh.wikipedia.org/wiki/%E5%8C%BA%E5%9F%9F%E8%AE%BE%E7%BD%AE
字符集和字符编码（Charset & Encoding）:: http://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html
UTF-8 and Unicode FAQ:: http://www.linuxforum.net/books/UTF-8-Unicode.html
C++的中英文字符串表示(string,wstring):: http://www.cnblogs.com/xiaoyz/archive/2008/10/11/1308860.html
彻底解密C++宽字符:: http://www.cppblog.com/lf426/archive/2010/06/25/118707.html
UCS-2与UTF8之间的选择:: http://blog.csdn.net/vagrxie/archive/2009/03/01/3947195.aspx
