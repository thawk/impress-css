= C++单元测试经验交流
:Author: 深圳证券通信有限公司 谭浩通
:slidebackground: frontpage
:numbered:
:data-uri:

ifdef::backend-slidy2[:slidebackground: content]
== C++单元测试的难点

ifdef::backend-slidy2[]
include::slidybackgrounds.txt[]
endif::backend-slidy2[]

* C++是静态、强类型编程语言，缺少Java、.Net中的反射机制。
* C++缺少标准化的把对象变成字符串的手段。

== C++单元测试实践

ifdef::backend-slidy2[>>>]
=== 单元测试代码的组织

* 单元测试代码放在++unittest++目录中

* ++init_test.cpp++文件中存放单元测试初始化代码
** 日志初始化
** 设置++test suite++名称
** 根据日志输出格式（文本/XML，在++Jamfile++中根据是否在持续集成中运行进行设置）

ifdef::backend-slidy2[<<<]
* 原则上每个类对应一个单元测试文件，命名为++test_**类名**.cpp++

* 每个单元测试文件编译为一个可执行文件
** 一个单元测试编译失败，不影响其它单元测试的执行
** 避免不同单元测试文件之间的互相干扰
*** 全局变量、静态变量的干扰
*** 程序崩溃的干扰

* 单元测试依赖于被测模块的整体，而不仅仅依赖于被测类
+
通过把被测模块编译为一个库，单元测试链接该库来实现。

=== 单元测试框架

* 单元测试框架： ++Boost.Test++（http://www.boost.org/libs/test） 
* 模拟对象框架： ++Turtle++（http://turtle.sourceforge.net/）
+
A C++ mock object library for Boost。

==== Boost.Test


=== 提高代码的可测试性

* 独立运行
* 覆盖输入
** 外部输入
+
参数、全局变量、成员变量

** 内部输入

*** 调用其它方法的返回值。
+
时钟、硬件信息、操作系统信息、环境变量等内容可能每次都不同。
+
一些比较复杂的方法，难以通过传入参数使方法返回想要的值。

*** 局部静态变量
+
每个用例的值都不同。
+
无法从外部访问。

=== 通过重载流插入运算符（<<）把对象变成可读字符串

=== 利用虚函数来拦截、模拟一些调用

=== 避免在多个线程中同时执行断言

=== Turtle的一些常见用法

==== MOCK_BASE_CLASS中，继承自使用有多个模板参数的模板类

由于宏对逗号的处理问题，简单使用 ++MOCK_BASE_CLASS(Class, Base<A1,A2>)++ 是会报错的（要求2个参数，提供了3个）。

把逗号换为++BOOST_PP_COMMA()++就可以了：

[source,cpp]
----
#include <boost/preprocessor/comma.hpp>

MOCK_BASE_CLASS(Class, Base<A1 BOOST_PP_COMMA() A2>)
----

== 持续集成工具

为了把C++单元测试集成到持续集成环境中，在持续集成环境中查看单元测试结果，并且自动对单元测试的代码覆盖率进行分析，需要一些额外工具的支持。

=== 单元测试结果收集及展示

.xUnit -- 单元测试结果收集插件

=== 单元测试代码覆盖率分析及展示

.gcov + gcovr -- 单元测试覆盖率分析工具

. - 单元测试覆盖率分析插件

== 谢谢

[width="100%",grid="none",frame="none"]
|=============================================
| |*Powered by*
| |image:images/asciidoc.png["AsciiDoc",align="right"]
| |*and* image:images/w3c_home.png["W3C",align="right"] Slidy
|=============================================

