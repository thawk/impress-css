= bjam基本使用
:Author: 谭浩通
:Date: 2011年12月15日
:toc:

== bjam是什么

* bjam是包含在知名的Boost C\++ library中，类似make的软体建构工具。虽
然似乎只是拿来编译Boost 的附属工具，但其实它的功能非常强大，同时改善了
许多make的缺点，相当适合用来建构C++ 软体。

* 我们提到“bjam”时，其实指的不是Boost.Jam而是Boost.Build。为了避免大家
的误解，在新版boost库中，所使用的命令已经从“bjam”改名为“bb”了。

  ** Boost.Jam是一个程序，其的前身是FTJam ，而FTJam又是从Perforce Jam
  发展出来的软体建构工具。Jam是一种主要面向文字处理的编程语言。
  
  ** Boost.Build则是一套构建环境，主要面向C++程序，由Boost.Jam和一系
  列用 Jam 语言编写的脚本组成。支持Windows、OSX、Linux和大量商业UNIX平
  台。

== 为什么用bjam？

在Boost.Build主页上，提到其几个重要特性：

简洁的高层描述::
  通常情况下，只需要提供构建对象的名称和所使用的源文件即可，不需要底层
  细节。

可移植性::
  大部分重要的编译选项（如debug/release、线程模型、静态/动态库等）都提
  供了标准的属性设置。

可以同时编译不同变种::
  由于使用不同编译选项得到的不同版本（不同编译器版本、debug/release、
  不同线程模型等）放在不同的目录下，因此可以同时编译多个不同的版本。

ifdef::backend-slidy2[<<<]
全局依赖检查::
  Boost.Build会自动分析程序中对头文件的依赖，并会对整个项目中的文件进
  行依赖检查，修改了一个文件会让所有使用者重新编译，避免项目中不同部分
  使用同一个文件的不同版本所导致的问题。

使用需求::
  每个编译对象都可以指定使用需求，如应该加入什么include路径，使用什么
  编译选项，使用该编译对象的地方都会自动加入这些需求。如一个组件声明只
  能用多线程方式进行编译的话，所有使用这个组件的地方都会自动使用多线程
  。

独立::
  Boost.Build本身只依赖于C编译器，不依赖于Boost库，因此很容易建立
  Boost.Build环境。如果需要的话，也可以把Boost.Build直接加入到你的项目
  中。

== 如何获得bjam？

* 可从Boost.Build主页单独下载
+
http://www.boost.org/boost-build2/

* 可使用Boost库中提供的Boost.Build版本

== bjam基础

ifdef::backend-slidy2[>>>]
=== 最简单的Jamfile

.test.cpp
[source,cpp]
--------------------
#include <iostream>
using namespace std;

int main()
{
    cout << "Hello world!" << endl;
    return 0;
}
--------------------

.Jamroot
--------------------
exe test : test.cpp ;
--------------------

NOTE: 每个项目，必须有一个Jamroot

=== bjam基本语法

* 空格、换行等作用一致，都视为spaces
* 每条语句必须以分号（;）结束
* 语句可以跨行
* 不同语法元素之间必须用spaces隔开。因此，冒号、等号、分号等的前后都必
须用空格分隔，++a=b;++是错误的，应写为++a = b ;++

=== 基本声明格式

通常来说，在Jamfile中声明一个target的语法如下：

--------------------
rule-name target-name : sources : requirements : default-build :
usage-requirements ;
--------------------

* ++rule-name++中，常用的是exe和lib，分别编译出可执行程序和库文件。

* ++target-name++是要编译出来的文件名，不需要扩展名，bjam会根据目标类
型的操作系统等信息自动决定扩展名。

* ++sources++是源文件以及所依赖的其它target和组件。可以使用++[ glob
*.cpp ]++来收集当前目录下的所有.cpp文件。缺省是Jamfile所在目录，也可以
通过在project中设置source-location来修改。
+
--------------------
lib helper : helper.cpp ;
exe a : a.cpp helper ;
exe b : b.cpp ..//utils ;
exe c : c.cpp /boost/program_options//program_options ;
exe d : [ glob *.cpp ] ;
--------------------

ifdef::backend-slidy2[<<<]

* ++requirements++是编译本target所**必需**的编译选项。

* ++default-build++是一些缺省的编译选项。可以被命令行或其它有依赖关系
target传播的值覆盖。

* ++usage-requirements++是一些会被传播到所有使用本target的target的编译
选项。比如可以指定一个include路径，可以指定使用多线程等。

== 配合组件库使用

ifdef::backend-slidy2[>>>]
=== 组件库的内容

组件库中主要有三大部分的组件：

boost库:: 包含了完整的boost库，并包含了Boost.Log。
预编译好的C库:: 由于使用标准C编写的库有各个平台上都有相应的二进制标准
，因此可以预先为各个平台编译好，不需要各自编译。
sscc-libs:: 公司各个项目组贡献的组件。

=== Boost.Build环境的准备

组件库中已经还包含了一套Boost.Build环境，使用者可以直接使用，不需要从
互联网上下载。

NOTE: 由于不同版本Boost库包含的Boost.Build不一致相同，因此也推荐直接使
用组件库中自带的Boost.Build。

环境准备：

. 下载或check out组件库到一个目录
. 执行组件库目录下的++bootstrap.bat++或++bootstrap.sh++，编译出所需的
Boost.Build可执行文件

=== 使用Boost.Build进行编译

由于Boost.Build是由一个可执行程序（bjam.exe或bb.exe）及一系列的
Boost.Build脚本组成，因此，要使用Boost.Build进行编译就必须让bjam知道
Boost.Build所在的目录。在组件库中，该目录是在组件库目录下的
++/tools/build/v2++目录中。

ifdef::backend-slidy2[<<<]
* 通过一个脚本运行bjam，在脚本中自动设置组件库及Boost.Build的目录。
+
--
NOTE: 脚本中的++-j2++表示同时启动两个进程编译两个文件，可根据CPU数量进
行适当配置，有助于提高编译速度。

Linux下的++bjam++脚本：

[source,sh]
--------------------
#!/bin/sh

export SSCC_COMPONENT_LIBS_ROOT=组件库路径
export BOOST_BUILD_PATH=${SSCC_COMPONENT_LIBS_ROOT}/tools/build/v2
${SSCC_COMPONENT_LIBS_ROOT}/bjam -j2 "$@"
--------------------

Windows下的++bjam.bat++脚本：

[source,bat]
--------------------
set SSCC_COMPONENT_LIBS_ROOT=组件库路径
set BOOST_BUILD_PATH=%SSCC_COMPONENT_LIBS_ROOT%\tools\build\v2
@%SSCC_COMPONENT_LIBS_ROOT%\bjam.exe -j2 %*
--------------------
--

ifdef::backend-slidy2[<<<]
* 在项目的根目录下，提供一个++boost-build.jam++文件，在文件中设置相应
的路径。
+
--------------------
SSCC_COMPONENT_LIBS_ROOT = 组件库路径 ;
BOOST_BUILD_PATH = $(SSCC_COMPONENT_LIBS_ROOT)/tools/build/v2 ;
boost-build $(BOOST_BUILD_PATH) ;
--------------------

=== 如何引用组件库中的组件

* 需要编译的boost库组件
+
+/boost/**库名**//boost_**库名**+
+
如： +/boost/**filesystem**//boost_**filesystem**+

* 不需要编译的boost库组件
+
boost库中专门提供了一个++headers++代表了boost库中所有头文件。项目只要
依赖++/boost//headers++即可

* 预编译好的C库
+
组件库中，+openssl/zlib+ 等库以预编译方式提供，其引用方式为：
+
+/C-libs-prebuilt/**库名**-**版本**//C_libs_**库名**-**版本**+
+
如： +/C-libs-prebuilt/**zlib**-**1.2.5**//C_libs_**zlib**-**1.2.5**+

* sscc-libs
+
+/sscc_libs/**组件名**//sscc_**组件名**+
+
如： +/sscc_libs/**WanM**//sscc_**WanM**+

== 使用bjam的项目例子

ifdef::backend-slidy2[>>>]
=== OEVS项目的目录结构

在OEVS项目中，

* 不打算重用的代码放在++01source++中，++Jamfile++、 +\*.h+ 、
++\*.cpp++放在一个目录下。

* 打算重用的组件代码放在++02lib++中，按组件库的架构，把++Jamfile++、
++\*.h++和++*.cpp++分别放到++build-with-bjam++、++include++、++src++
目录下，++include++中再建立++sscc/组件名称/++子目录，把头文件放到该子
目录下，以便通过++#include <sscc/组件名称/header.h>++的方式包含相应的
头文件。

--------------------
+-- 01source
|   +-- Jamroot
|   +-- collector/
|   |   +-- Jamfile、*.h、*.cpp
|   |   +-- test/
|   +-- validator/
|   |   +-- Jamfile、*.h、*.cpp
|   |   +-- test/
|   +-- util/
|   |   +-- Jamfile、*.h、*.cpp
|   |   +-- test/
|   +-- server/
|   |   +-- Jamfile、*.h、*.cpp
|   |   +-- test/
|   +-- webui/
|       +-- Jamfile、*.h、*.cpp
|       +-- test/
+-- 02lib
    +-- Jamroot
    +-- permission
        +-- build-with-bjam
        |     Jamfile
        +-- include
        |   +-- sscc
        |       +-- permission
        |             *.h
        +-- test/
--------------------

=== OEVS项目中用到的Jamfile

ifdef::backend-slidy2[>>>]
==== 01source/Jamroot

主要设置了整个项目用到的一些编译选项和include路径，引入了组件库和02lib
中的组件，引入了单元测试。

--------------------
import modules ;

# in sscc::log, use Boost.Log
modules.poke : USE_BOOST_LOG : 1 ;

# declare the common compile flags and the include path
project oevs
    : requirements
      <target-os>windows:<define>_WIN32_WINNT=0x0501
 	    <conditional>@requirements
      <link>static
      <threading>multi
      <include>.
    ;

# import the component libs
if ! $(SSCC_COMPONENT_LIBS_ROOT)
{   
    SSCC_COMPONENT_LIBS_ROOT = [ modules.peek : SSCC_COMPONENT_LIBS_ROOT ] ;   
}    

use-project /sscc_component_libs : $(SSCC_COMPONENT_LIBS_ROOT) ;
use-project lib : ../02lib ;

# build webui agent when no target is specified
build-project webui ;
build-project agent ;

# use bjam test to run all unit-tests in 01source/ and 02lib/
all-tests = [ MATCH (.*)/Jamfile : [ glob */test/Jamfile ] ] ;
explicit test ;
alias test : ../02lib//test $(all-tests) ;

# set different compile options for different  compiler
rule requirements ( properties * )
{
    local result ;

    # Disable some annoying warnings of VC
    if <toolset>msvc in $(properties) 
    {
        result += <cxxflags>-wd4996 ;
        result += <cxxflags>-wd4819 ;
        result += <cxxflags>-wd4503 ;

        result += <linkflags>/ignore:4099 ;
    }
	
    # Force warning to error of g++
    if <toolset>gcc in $(properties)
    {
        #result += <cxxflags>-Werror=return-type ;
    }

    return $(result) ;
}
--------------------

==== 01source/server/Jamfile

server是以库的形式出现，因此target类型是lib。具体的配置很简单，只是列
出了所要使用的源代码（本目录下所有.cpp文件）以及所依赖的库（本项目中的
collector/validator及组件库中的几个组件以及boost库中不需要编译的组件）
。

--------------------
lib server
    : [ glob *.cpp ]
      ../collector//collector
      ../validator//validator
      /sscc_libs/permission//sscc_permission
      /sscc_libs/WanM//sscc_WanM
      /boost//headers
    ;
--------------------

==== 01source/webui/Jamfile

webui是一个可执行程序，因此target类型是exe。其它配置和server差不多。

--------------------
exe webui
    : [ glob *.cpp ]
      ../server//server
      /sscc_libs/httpserver//sscc_httpserver
      /sscc_libs/comet//sscc_comet
      /boost//headers
    ;
--------------------

==== 02lib/Jamroot

02lib存放的是本项目提供的可重用的组件。其Jamroot也很简单，同样是引入了
组件库，再为本项目的几个组件提供了一个别名，方便别人引用，再就是引入了
单元测试代码。

--------------------
if ! $(SSCC_COMPONENT_LIBS_ROOT)
{   
    SSCC_COMPONENT_LIBS_ROOT = [ modules.peek : SSCC_COMPONENT_LIBS_ROOT ] ;   
}    

if $(SSCC_COMPONENT_LIBS_ROOT)
{
    use-project /sscc_component_libs : $(SSCC_COMPONENT_LIBS_ROOT) ;
}

use-project /jsoncpp : jsoncpp/build-with-bjam ;
use-project /sscc_libs/comet : comet/build-with-bjam ;
use-project /sscc_libs/permission : permission/build-with-bjam ;

# unit-test
all-tests = [ MATCH (.*)/Jamfile : [ glob */test/Jamfile ] ] ;
explicit test ;
alias test : $(all-tests) ;
--------------------

==== 02lib/permission/build-with-bjam/Jamfile

--------------------
import os ;
import path ;

project sscc_libs/permission
    : source-location ../src
    : requirements
      <link>static:<define>SSCC_LIB_BUILD_LIB=1
      <link>shared:<define>SSCC_LIB_BUILD_DLL=1
    : default-build <threading>multi
    ;

layout = [ option.get layout : "" ] ;

rule requirements ( properties * )
{
    local result = $(properties) ;

    if <target-os>windows in $(properties) 
    {
        result += <define>_WIN32_WINNT=0x0501 ;
        if $(layout) = system
        {
            result += <define>BOOST_ALL_NO_LIB ;
        }
    }
    else if <target-os>linux in $(properties)
    {
    }
    
    return $(result) ;
}

alias permission_sources
    : [ glob *.cpp ]
    ;

lib sscc_permission
    : permission_sources
      /sscc_libs/log//sscc_log
      /boost/thread//boost_thread
      /boost/filesystem//boost_filesystem
      /boost/date_time//boost_date_time
      /boost//headers
    : <conditional>@requirements 
      <include>../include
    :
    : <link>shared:<define>SSCC_LIB_USE_DLL=1
      <link>static:<define>SSCC_LIB_USE_LIB=1
      <include>../include
    ;
--------------------

=== OEVS项目中，单元测试的例子

ifdef::backend-slidy2[>>>]
==== 01source/collector/test/Jamfile

脚本中，程序名称通过TARGET变量取得其上一层目录的名称（collector ），并
通过PROJECT_PATH变量取得Jamfile所在目录的绝对路径，通过参数传给程序，
以便正确设置当前目录

--------------------
import testing ;
import path ;

path-constant PROJECT_PATH : . ;

TARGET = [ path.basename [ path.parent $(PROJECT_PATH) ] ] ;

run [ glob *.cpp ]
    /boost/test//boost_unit_test_framework
	  ../
    : $(PROJECT_PATH)
    :
    :
    : $(TARGET)
    ;
--------------------

==== 01source/collector/test/test_main.cpp

本段代码为单元测试的入口代码，对日志模块进行初始化，并把当前目录修改为
参数中传入的值，创建了“output”目录用于存放测试结果，还把Boost.Test的日
志存放于test-reports/test_log.xml中，可以配合Hudson/Jenkins的xUnit插件
生成单元测试的统计信息。

NOTE: 这里用的是 #include <boost/test/included/unit_test.hpp>

[source,cpp]
--------------------
#define BOOST_TEST_ALTERNATIVE_INIT_API
#include <boost/test/included/unit_test.hpp>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/fstream.hpp>
#include <sscc/log/config.h>

using boost::filesystem::create_directory;
using boost::filesystem::current_path;
using boost::filesystem::ofstream;
using boost::filesystem::path;
using boost::unit_test::framework::master_test_suite;
using boost::unit_test::unit_test_log;

static ofstream ms_testLog;

static const path TEST_OUTPUT_PATH=path("output");
static const path TEST_REPORTS_PATH=path("test-reports");
static const path TEST_REPORT_FILE=TEST_REPORTS_PATH / "test_log.xml";

bool init_unit_test()
{
    SSCC_LOG_CONFIG_CONSOLE();

    // 把当前路径改为第一个参数
    if (master_test_suite().argc > 1)
        current_path(master_test_suite().argv[1]);

    create_directory(TEST_OUTPUT_PATH);
    create_directory(TEST_REPORTS_PATH);

    ms_testLog.open(TEST_REPORT_FILE, std::ios_base::out | std::ios_base::trunc);

    if (ms_testLog)
    {   // 把测试日志重定向到report/test_log.xml，格式定为XML
        // ms_testLog的生命期可以延续到日志使用结束后，因此不需要恢复原来的stream
        unit_test_log.set_stream(ms_testLog);
        unit_test_log.set_format(boost::unit_test::XML);
        unit_test_log.set_threshold_level(boost::unit_test::log_successful_tests);
    }

    return true;
}
--------------------

==== 01source/collector/test/test_file_md5_collect_request.cpp

前面是两个辅助函数，然后用 BOOST_AUTO_TEST_SUITE() 声明一个test suite
，再用多个 BOOST_AUTO_TEST_CASE() 声明多个单元测试案例。

NOTE: 这里用的是 #include <boost/test/unit_test.hpp>

[source,cpp]
--------------------
#include <boost/filesystem/operations.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/xml_parser.hpp>
#include <boost/test/unit_test.hpp>
#include "collector/file_md5_request.h"

using std::string;
using boost::filesystem::current_path;
using boost::filesystem::path;
using boost::property_tree::ptree;
using boost::property_tree::xml_parser::write_xml;
using boost::system::error_code;
using namespace sscc::oevs::collector;

namespace sscc {
namespace oevs {
namespace collector {

namespace {

bool operator==(const FileMD5CollectRequest& lhs, const FileMD5CollectRequest& rhs)
{
    BOOST_REQUIRE_EQUAL(lhs.GetType(), rhs.GetType());
    BOOST_REQUIRE_EQUAL(lhs.GetName(), rhs.GetName());

    return true;
}

void LoadSave(const string& testName, const FileMD5CollectRequest& request)
{
    ptree pt;
    BOOST_REQUIRE_EQUAL(request.Save(pt), error_code());

    write_xml(path("output/" + testName + ".xml").file_string(), pt);

    error_code ec;
    CollectRequestPtr request1 = CollectRequest::Load(pt, ec);
    FileMD5CollectRequestPtr fileMD5Request = boost::dynamic_pointer_cast<FileMD5CollectRequest>(request1);

    BOOST_CHECK_EQUAL(ec, error_code());
    BOOST_REQUIRE(request1);
    BOOST_REQUIRE(fileMD5Request);

    BOOST_REQUIRE(request == *fileMD5Request);
}

}
}}}

BOOST_AUTO_TEST_SUITE( test_file_md5_request )

BOOST_AUTO_TEST_CASE( test_file_md5_request1 )
{
    FileMD5CollectRequest request;
    LoadSave("test_file_md5_request1", request);
}

BOOST_AUTO_TEST_CASE( test_file_md5_request2 )
{
    FileMD5CollectRequest request((current_path() / "*").file_string());
    //FileMD5CollectRequest request("/etc/rndc*");
    BOOST_REQUIRE_EQUAL(request.GetTotalItemCount(), 0u);
    request.Collect();
    BOOST_REQUIRE(request.GetTotalItemCount() > 0);
    BOOST_REQUIRE(request.GetSuccessfulItemCount() > 0);
    LoadSave("test_file_md5_request2", request);
}

BOOST_AUTO_TEST_SUITE_END()
--------------------

== 进阶话题

ifdef::backend-slidy2[>>>]
=== 只有头文件的库

对于只有头文件的库，没有源文件，也很可能不需要设置任何编译选项，但需要
修改include路径，可以通过alias起别名的方式让其它target使用。

--------------------
alias my-lib
    : # no sources
    : # no build requirements
    : # no default build
    : <include>whatever ;
--------------------

=== 单元测试

* Jamroot中把所有test目录下的Jamfile文件都视为单元测试文件，可以通过
++bjam test++调用。
+
--------------------
all-tests = [ MATCH (.*)/Jamfile : [ glob */test/Jamfile ] ] ;
explicit test ;
alias test : $(all-tests) ;
--------------------

* 02lib/permission/build-with-bjam/Jamfile
+
--------------------
import testing ;
import path ;

path-constant PROJECT_PATH : . ;

TARGET = [ path.basename [ path.parent $(PROJECT_PATH) ] ] ;

run [ glob *.cpp ]
    /boost/test//boost_unit_test_framework
    /sscc_libs/permission//sscc_permission
    : $(PROJECT_PATH)
    :
    : <link>static
      <threading>multi
    : $(TARGET)
    ;
--------------------

=== 依赖于bjam生成的头文件

可利用<dependency>来指定一个lib/exe依赖于动态生成的头文件

https://svn.boost.org/svn/boost/sandbox/tools/build_extensions/ext/gif.jam

--------------------
    make config.h : : @config_h
        :   <gif-version>$(version)
            <location-prefix>src
        ;

    lib gif
        :
            ...
        :   $(requirements)
            ...
        :
        :   <include>$(location)
            <implicit-dependency>config.h
            <dependency>config.h
        ;
--------------------

=== 调用外部工具

使用make规则，可以进行文件拷贝、目录创建等动作。

--------------------
import common ;
make $(C_LIB_ROOT)/include/openssl/opensslconf.h : ./win32/opensslconf.h.nt : common.copy ;
--------------------

=== 在bjam中调用configure/make

http://lists.boost.org/boost-build/2006/07/14428.php

--------------------
actions automake
{
  cd $(<)
  ./configure
  make
}

make fftw : /usr/path/to/fftw : @automake ;
make zlib : /usr/path/to/zlib : @automake ; 
--------------------

一个用了zlib等库的Jamfile例子。

https://trac.handbrake.fr/browser/trunk/contrib/Jamfile?rev=559

=== 把新的扩展名和文件类型关联起来

有时会遇到一些非标准的扩展名，此时会报 ++target XXX has no type++。

----
import type ;
type.register-suffixes ipp : CPP ;
----
